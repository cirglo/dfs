
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>nameserver: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cirglo.com/dfs/cmd/nameserver/main.go (0.0%)</option>
				
				<option value="file1">github.com/cirglo.com/dfs/cmd/nodeserver/main.go (0.0%)</option>
				
				<option value="file2">github.com/cirglo.com/dfs/pkg/mocks/BlockService.go (0.0%)</option>
				
				<option value="file3">github.com/cirglo.com/dfs/pkg/mocks/ConnectionFactory.go (0.0%)</option>
				
				<option value="file4">github.com/cirglo.com/dfs/pkg/mocks/FileService.go (0.0%)</option>
				
				<option value="file5">github.com/cirglo.com/dfs/pkg/mocks/HealingService.go (0.0%)</option>
				
				<option value="file6">github.com/cirglo.com/dfs/pkg/mocks/NameClient.go (0.0%)</option>
				
				<option value="file7">github.com/cirglo.com/dfs/pkg/mocks/NameServer.go (0.0%)</option>
				
				<option value="file8">github.com/cirglo.com/dfs/pkg/mocks/NodeClient.go (0.0%)</option>
				
				<option value="file9">github.com/cirglo.com/dfs/pkg/mocks/NodeServer.go (0.0%)</option>
				
				<option value="file10">github.com/cirglo.com/dfs/pkg/mocks/NotificationClient.go (0.0%)</option>
				
				<option value="file11">github.com/cirglo.com/dfs/pkg/mocks/NotificationServer.go (0.0%)</option>
				
				<option value="file12">github.com/cirglo.com/dfs/pkg/mocks/Principal.go (0.0%)</option>
				
				<option value="file13">github.com/cirglo.com/dfs/pkg/mocks/SecurityService.go (0.0%)</option>
				
				<option value="file14">github.com/cirglo.com/dfs/pkg/name/file.go (34.6%)</option>
				
				<option value="file15">github.com/cirglo.com/dfs/pkg/name/healing.go (0.0%)</option>
				
				<option value="file16">github.com/cirglo.com/dfs/pkg/name/notificationserver.go (0.0%)</option>
				
				<option value="file17">github.com/cirglo.com/dfs/pkg/name/permission.go (0.0%)</option>
				
				<option value="file18">github.com/cirglo.com/dfs/pkg/name/principal.go (5.1%)</option>
				
				<option value="file19">github.com/cirglo.com/dfs/pkg/name/privileges.go (0.0%)</option>
				
				<option value="file20">github.com/cirglo.com/dfs/pkg/name/security.go (0.0%)</option>
				
				<option value="file21">github.com/cirglo.com/dfs/pkg/name/server.go (0.0%)</option>
				
				<option value="file22">github.com/cirglo.com/dfs/pkg/node/block.go (73.6%)</option>
				
				<option value="file23">github.com/cirglo.com/dfs/pkg/node/server.go (56.0%)</option>
				
				<option value="file24">github.com/cirglo.com/dfs/pkg/proto/connection.go (0.0%)</option>
				
				<option value="file25">github.com/cirglo.com/dfs/pkg/proto/names.pb.go (0.0%)</option>
				
				<option value="file26">github.com/cirglo.com/dfs/pkg/proto/names_grpc.pb.go (0.0%)</option>
				
				<option value="file27">github.com/cirglo.com/dfs/pkg/proto/nodes.pb.go (0.0%)</option>
				
				<option value="file28">github.com/cirglo.com/dfs/pkg/proto/nodes_grpc.pb.go (0.0%)</option>
				
				<option value="file29">github.com/cirglo.com/dfs/pkg/proto/notifications.pb.go (0.0%)</option>
				
				<option value="file30">github.com/cirglo.com/dfs/pkg/proto/notifications_grpc.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "github.com/cirglo.com/dfs/pkg/name"
        "github.com/cirglo.com/dfs/pkg/proto"
        "github.com/sirupsen/logrus"
        "google.golang.org/grpc"
        "net"
        "time"

        "gorm.io/driver/mysql"
        "gorm.io/driver/postgres"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
)

func main() <span class="cov0" title="0">{
        logLevelFlag := flag.String("log-level", "info", "Log Level")
        hostFlag := flag.String("host", "localhost", "Node Host")
        portFlag := flag.Int("port", 53035, "Port to listen on")
        dbDriverFlag := flag.String("db-driver", "sqlite", "Database Driver (sqlite, postgres, mysql)")
        dsnFlag := flag.String("dsn", "nameserver.db", "Data Source Name (DSN) for the database")
        dbPoolMaxIdleConnectionsFlag := flag.Int("db-pool-max-idle-connections", 10, "Max Idle Connections in the DB Pool")
        dbPoolMaxOpenConnectionsFlag := flag.Int("db-pool-max-open-connections", 100, "Max Open Connections in the DB Pool")
        dbPoolMaxLifetimeFlag := flag.Duration("db-pool-max-lifetime", 1*time.Hour, "Max Lifetime of Connections in the DB Pool")
        dbPoolMaxIdleTimeFlag := flag.Duration("db-pool-max-idle-time", 10*time.Minute, "Max Lifetime of Connections in the DB Pool")
        tokenExpirationFlag := flag.Duration("token-expiration", 24*time.Hour, "Token Expiration duration")
        numReplicasFlag := flag.Uint("num-replicas", 1, "Number of replicas")
        nodeExpirationFlag := flag.Duration("node-expiration", 15*time.Minute, "Node Expiration duration")
        healingIntervalFlag := flag.Duration("healing-interval", 1*time.Minute, "Healing interval")
        var dialector gorm.Dialector

        flag.Parse()

        log := logrus.New()
        logLevel, err := logrus.ParseLevel(*logLevelFlag)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).WithField("level", *logLevelFlag).Fatalf("Invalid log level")
        }</span>

        <span class="cov0" title="0">log.SetLevel(logLevel)

        log.WithField("driver", *dbDriverFlag).Info("Opening Database")
        switch *dbDriverFlag </span>{
        case "sqlite":<span class="cov0" title="0">
                dialector = sqlite.Open(*dsnFlag)</span>
        case "postgres":<span class="cov0" title="0">
                dialector = postgres.Open(*dsnFlag)</span>
        case "mysql":<span class="cov0" title="0">
                dialector = mysql.Open(*dsnFlag)</span>
        default:<span class="cov0" title="0">
                log.Fatalf("Invalid database driver: %s", *dbDriverFlag)</span>
        }

        <span class="cov0" title="0">log.WithField("driver", *dbDriverFlag).Info("Creating database connection")
        db, err := createDB(dialector)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to create database")
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to get SQL DB")
        }</span>
        <span class="cov0" title="0">log.Info("Database connection created")

        sqlDB.SetMaxIdleConns(*dbPoolMaxIdleConnectionsFlag)
        sqlDB.SetMaxOpenConns(*dbPoolMaxOpenConnectionsFlag)
        sqlDB.SetConnMaxLifetime(*dbPoolMaxLifetimeFlag)
        sqlDB.SetConnMaxIdleTime(*dbPoolMaxIdleTimeFlag)

        err = sqlDB.Ping()
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to ping database")
        }</span>
        <span class="cov0" title="0">log.Info("Database connection established")

        log.Info("Creating services")
        securityService, err := name.NewSecurityService(name.SecurityServiceOpts{
                Logger:           log,
                DB:               db,
                TokenExperiation: *tokenExpirationFlag,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to create security service")
        }</span>

        <span class="cov0" title="0">fileService, err := name.NewFileService(name.FileServiceOpts{
                Logger: log,
                DB:     db,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to create file service")
        }</span>

        <span class="cov0" title="0">log.Info("Creating server")
        server := name.Server{Opts: name.ServerOpts{
                Logger:          log,
                SecurityService: securityService,
                FileService:     fileService}}

        healingService, err := name.NewHealingService(name.HealingOpts{
                Logger:            log,
                NumReplicas:       *numReplicasFlag,
                FileService:       fileService,
                NodeExpiration:    *nodeExpirationFlag,
                ConnectionFactory: proto.NewInsecureConnectionFactory(),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to create healing service")
        }</span>

        <span class="cov0" title="0">notificationServer := name.NotificationServer{
                FileService:    fileService,
                HealingService: healingService,
        }

        log.WithField("host", *hostFlag).WithField("port", *portFlag).Info("Starting network listener")
        listener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", *hostFlag, *portFlag))
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to listen")
        }</span>

        <span class="cov0" title="0">grpcServer := grpc.NewServer()
        proto.RegisterNameServer(grpcServer, server)
        proto.RegisterNotificationServer(grpcServer, notificationServer)

        go func() </span><span class="cov0" title="0">{
                t := time.NewTicker(*healingIntervalFlag)
                for range t.C </span><span class="cov0" title="0">{
                        err := healingService.Heal(time.Now())
                        if err != nil </span><span class="cov0" title="0">{
                                log.WithError(err).Fatal("Healing failed")
                        }</span>
                }
        }()

        <span class="cov0" title="0">log.Info("Starting gRPC server")
        if err := grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to serve gRPC server")
        }</span>
}

func createDB(dialector gorm.Dialector) (*gorm.DB, error) <span class="cov0" title="0">{
        db, err := gorm.Open(dialector, &amp;gorm.Config{
                SkipDefaultTransaction:   true,
                DisableNestedTransaction: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not open database: %w", err)
        }</span>
        <span class="cov0" title="0">err = db.AutoMigrate(
                name.User{},
                name.Group{},
                name.Token{},
                name.Permissions{},
                name.FileInfo{},
                name.Permission{},
                name.BlockInfo{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to auto migrate: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flag"
        "fmt"
        "github.com/cirglo.com/dfs/pkg/node"
        "github.com/cirglo.com/dfs/pkg/proto"
        "github.com/sirupsen/logrus"
        "google.golang.org/grpc"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        "net"
        "os"
        "time"
)

func main() <span class="cov0" title="0">{
        logLevelFlag := flag.String("log-level", "info", "Log Level")
        nameNodeFlag := flag.String("name-node", "localhost:53035", "Name Node Address")
        dirFlag := flag.String("dir", "./", "Node Directory")
        dsnFlag := flag.String("dsn", "nodeserver.db", "Data Source Name (DSN) for the database")
        hostFlag := flag.String("host", "localhost:55055", "Node Host")
        reportIntervalFlag := flag.Duration("report-interval", 10*time.Minute, "Report Interval")
        healthCheckIntervalFlag := flag.Duration("health-check-interval", 1*time.Hour, "Health Check Interval")
        crcCheckIntervalFlag := flag.Duration("crc-check-interval", 24*time.Hour, "CRC Check Interval")

        flag.Parse()

        log := logrus.New()
        logLevel, err := logrus.ParseLevel(*logLevelFlag)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).WithField("level", *logLevelFlag).Fatal("Invalid log level")
        }</span>

        <span class="cov0" title="0">log.SetLevel(logLevel)

        log.WithField("dir-path", *dirFlag).Info("Checking directory")
        _, err = os.Stat(*dirFlag)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).WithField("dir", *dirFlag).Fatal("Directory does not exist")
        }</span>

        <span class="cov0" title="0">log.WithField("dns", *dsnFlag).Info("Opening database")
        db, err := createDB(sqlite.Open(*dsnFlag))
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to create database")
        }</span>

        <span class="cov0" title="0">connectionFactory := proto.NewInsecureConnectionFactory()

        log.WithField("name-node", *nameNodeFlag).Info("Connecting to name node")
        conn, err := connectionFactory.CreateConnection(*nameNodeFlag)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to connect to name node")
        }</span>
        <span class="cov0" title="0">client := proto.NewNotificationClient(conn)

        serviceOpts := node.BlockServiceOpts{
                Logger:             log,
                Host:               *hostFlag,
                DB:                 db,
                Dir:                *dirFlag,
                NotificationClient: client,
        }

        log.Info("Creating block service")
        blockService, err := node.NewBlockService(serviceOpts)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to create block service")
        }</span>

        <span class="cov0" title="0">log.Info("Reporting to name node")
        err = blockService.Report()
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to report to name node")
        }</span>

        <span class="cov0" title="0">log.Info("Creating server")
        nodeServer, err := node.NewServer(node.ServerOpts{
                Logger:            log,
                BlockService:      blockService,
                ConnectionFactory: connectionFactory,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to create server")
        }</span>

        <span class="cov0" title="0">log.WithField("host", *hostFlag).Info("Creating Network listener")
        listener, err := net.Listen("tcp", *hostFlag)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to listen")
        }</span>

        <span class="cov0" title="0">grpcServer := grpc.NewServer()
        proto.RegisterNodeServer(grpcServer, nodeServer)

        log.Info("Starting grpc server")
        if err := grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("Failed to serve gRPC server")
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(*reportIntervalFlag)
                for range ticker.C </span><span class="cov0" title="0">{
                        log.Info("Report to name node")
                        err := blockService.Report()
                        if err != nil </span><span class="cov0" title="0">{
                                log.WithError(err).Fatal("report to name node failed")
                        }</span>
                        <span class="cov0" title="0">log.Info("Reported to name node")</span>
                }
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(*healthCheckIntervalFlag)
                for range ticker.C </span><span class="cov0" title="0">{
                        log.Info("Performing health check")
                        err := blockService.HealthCheck()
                        if err != nil </span><span class="cov0" title="0">{
                                log.WithError(err).Fatal("health check failed")
                        }</span>
                        <span class="cov0" title="0">log.Info("Health check done")</span>
                }
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(*crcCheckIntervalFlag)
                for range ticker.C </span><span class="cov0" title="0">{
                        log.Info("Validating CRC")
                        err := blockService.ValidateCRC()
                        if err != nil </span><span class="cov0" title="0">{
                                log.WithError(err).Fatal("validate CRC failed")
                        }</span>
                        <span class="cov0" title="0">log.Info("Finished validating CRC")</span>
                }
        }()

}

func createDB(dialector gorm.Dialector) (*gorm.DB, error) <span class="cov0" title="0">{
        db, err := gorm.Open(dialector, &amp;gorm.Config{
                SkipDefaultTransaction:   true,
                DisableNestedTransaction: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not open database: %w", err)
        }</span>
        <span class="cov0" title="0">err = db.AutoMigrate(node.BlockInfo{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to auto migrate: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        node "github.com/cirglo.com/dfs/pkg/node"
        mock "github.com/stretchr/testify/mock"
)

// BlockService is an autogenerated mock type for the BlockService type
type BlockService struct {
        mock.Mock
}

type BlockService_Expecter struct {
        mock *mock.Mock
}

func (_m *BlockService) EXPECT() *BlockService_Expecter <span class="cov0" title="0">{
        return &amp;BlockService_Expecter{mock: &amp;_m.Mock}
}</span>

// DeleteBlock provides a mock function with given fields: id
func (_m *BlockService) DeleteBlock(id string) error <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteBlock")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// BlockService_DeleteBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBlock'
type BlockService_DeleteBlock_Call struct {
        *mock.Call
}

// DeleteBlock is a helper method to define mock.On call
//   - id string
func (_e *BlockService_Expecter) DeleteBlock(id interface{}) *BlockService_DeleteBlock_Call <span class="cov0" title="0">{
        return &amp;BlockService_DeleteBlock_Call{Call: _e.mock.On("DeleteBlock", id)}
}</span>

func (_c *BlockService_DeleteBlock_Call) Run(run func(id string)) *BlockService_DeleteBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *BlockService_DeleteBlock_Call) Return(_a0 error) *BlockService_DeleteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *BlockService_DeleteBlock_Call) RunAndReturn(run func(string) error) *BlockService_DeleteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBlockIds provides a mock function with no fields
func (_m *BlockService) GetBlockIds() ([]string, error) <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBlockIds")</span>
        }

        <span class="cov0" title="0">var r0 []string
        var r1 error
        if rf, ok := ret.Get(0).(func() ([]string, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func() []string); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]string)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// BlockService_GetBlockIds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockIds'
type BlockService_GetBlockIds_Call struct {
        *mock.Call
}

// GetBlockIds is a helper method to define mock.On call
func (_e *BlockService_Expecter) GetBlockIds() *BlockService_GetBlockIds_Call <span class="cov0" title="0">{
        return &amp;BlockService_GetBlockIds_Call{Call: _e.mock.On("GetBlockIds")}
}</span>

func (_c *BlockService_GetBlockIds_Call) Run(run func()) *BlockService_GetBlockIds_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *BlockService_GetBlockIds_Call) Return(_a0 []string, _a1 error) *BlockService_GetBlockIds_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *BlockService_GetBlockIds_Call) RunAndReturn(run func() ([]string, error)) *BlockService_GetBlockIds_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBlocks provides a mock function with no fields
func (_m *BlockService) GetBlocks() ([]node.BlockInfo, error) <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBlocks")</span>
        }

        <span class="cov0" title="0">var r0 []node.BlockInfo
        var r1 error
        if rf, ok := ret.Get(0).(func() ([]node.BlockInfo, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func() []node.BlockInfo); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]node.BlockInfo)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// BlockService_GetBlocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlocks'
type BlockService_GetBlocks_Call struct {
        *mock.Call
}

// GetBlocks is a helper method to define mock.On call
func (_e *BlockService_Expecter) GetBlocks() *BlockService_GetBlocks_Call <span class="cov0" title="0">{
        return &amp;BlockService_GetBlocks_Call{Call: _e.mock.On("GetBlocks")}
}</span>

func (_c *BlockService_GetBlocks_Call) Run(run func()) *BlockService_GetBlocks_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *BlockService_GetBlocks_Call) Return(_a0 []node.BlockInfo, _a1 error) *BlockService_GetBlocks_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *BlockService_GetBlocks_Call) RunAndReturn(run func() ([]node.BlockInfo, error)) *BlockService_GetBlocks_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// HealthCheck provides a mock function with no fields
func (_m *BlockService) HealthCheck() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for HealthCheck")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// BlockService_HealthCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HealthCheck'
type BlockService_HealthCheck_Call struct {
        *mock.Call
}

// HealthCheck is a helper method to define mock.On call
func (_e *BlockService_Expecter) HealthCheck() *BlockService_HealthCheck_Call <span class="cov0" title="0">{
        return &amp;BlockService_HealthCheck_Call{Call: _e.mock.On("HealthCheck")}
}</span>

func (_c *BlockService_HealthCheck_Call) Run(run func()) *BlockService_HealthCheck_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *BlockService_HealthCheck_Call) Return(_a0 error) *BlockService_HealthCheck_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *BlockService_HealthCheck_Call) RunAndReturn(run func() error) *BlockService_HealthCheck_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ReadBlock provides a mock function with given fields: id
func (_m *BlockService) ReadBlock(id string) ([]byte, node.BlockInfo, error) <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ReadBlock")</span>
        }

        <span class="cov0" title="0">var r0 []byte
        var r1 node.BlockInfo
        var r2 error
        if rf, ok := ret.Get(0).(func(string) ([]byte, node.BlockInfo, error)); ok </span><span class="cov0" title="0">{
                return rf(id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) []byte); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]byte)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) node.BlockInfo); ok </span><span class="cov0" title="0">{
                r1 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Get(1).(node.BlockInfo)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(2).(func(string) error); ok </span><span class="cov0" title="0">{
                r2 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov0" title="0">return r0, r1, r2</span>
}

// BlockService_ReadBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadBlock'
type BlockService_ReadBlock_Call struct {
        *mock.Call
}

// ReadBlock is a helper method to define mock.On call
//   - id string
func (_e *BlockService_Expecter) ReadBlock(id interface{}) *BlockService_ReadBlock_Call <span class="cov0" title="0">{
        return &amp;BlockService_ReadBlock_Call{Call: _e.mock.On("ReadBlock", id)}
}</span>

func (_c *BlockService_ReadBlock_Call) Run(run func(id string)) *BlockService_ReadBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *BlockService_ReadBlock_Call) Return(_a0 []byte, _a1 node.BlockInfo, _a2 error) *BlockService_ReadBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1, _a2)
        return _c
}</span>

func (_c *BlockService_ReadBlock_Call) RunAndReturn(run func(string) ([]byte, node.BlockInfo, error)) *BlockService_ReadBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Report provides a mock function with no fields
func (_m *BlockService) Report() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Report")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// BlockService_Report_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Report'
type BlockService_Report_Call struct {
        *mock.Call
}

// Report is a helper method to define mock.On call
func (_e *BlockService_Expecter) Report() *BlockService_Report_Call <span class="cov0" title="0">{
        return &amp;BlockService_Report_Call{Call: _e.mock.On("Report")}
}</span>

func (_c *BlockService_Report_Call) Run(run func()) *BlockService_Report_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *BlockService_Report_Call) Return(_a0 error) *BlockService_Report_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *BlockService_Report_Call) RunAndReturn(run func() error) *BlockService_Report_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ValidateCRC provides a mock function with no fields
func (_m *BlockService) ValidateCRC() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ValidateCRC")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// BlockService_ValidateCRC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateCRC'
type BlockService_ValidateCRC_Call struct {
        *mock.Call
}

// ValidateCRC is a helper method to define mock.On call
func (_e *BlockService_Expecter) ValidateCRC() *BlockService_ValidateCRC_Call <span class="cov0" title="0">{
        return &amp;BlockService_ValidateCRC_Call{Call: _e.mock.On("ValidateCRC")}
}</span>

func (_c *BlockService_ValidateCRC_Call) Run(run func()) *BlockService_ValidateCRC_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *BlockService_ValidateCRC_Call) Return(_a0 error) *BlockService_ValidateCRC_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *BlockService_ValidateCRC_Call) RunAndReturn(run func() error) *BlockService_ValidateCRC_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WriteBlock provides a mock function with given fields: id, path, sequence, data
func (_m *BlockService) WriteBlock(id string, path string, sequence uint64, data []byte) error <span class="cov0" title="0">{
        ret := _m.Called(id, path, sequence, data)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WriteBlock")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, string, uint64, []byte) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id, path, sequence, data)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// BlockService_WriteBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteBlock'
type BlockService_WriteBlock_Call struct {
        *mock.Call
}

// WriteBlock is a helper method to define mock.On call
//   - id string
//   - path string
//   - sequence uint64
//   - data []byte
func (_e *BlockService_Expecter) WriteBlock(id interface{}, path interface{}, sequence interface{}, data interface{}) *BlockService_WriteBlock_Call <span class="cov0" title="0">{
        return &amp;BlockService_WriteBlock_Call{Call: _e.mock.On("WriteBlock", id, path, sequence, data)}
}</span>

func (_c *BlockService_WriteBlock_Call) Run(run func(id string, path string, sequence uint64, data []byte)) *BlockService_WriteBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(string), args[2].(uint64), args[3].([]byte))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *BlockService_WriteBlock_Call) Return(_a0 error) *BlockService_WriteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *BlockService_WriteBlock_Call) RunAndReturn(run func(string, string, uint64, []byte) error) *BlockService_WriteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewBlockService creates a new instance of BlockService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlockService(t interface {
        mock.TestingT
        Cleanup(func())
}) *BlockService <span class="cov0" title="0">{
        mock := &amp;BlockService{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        mock "github.com/stretchr/testify/mock"
        grpc "google.golang.org/grpc"
)

// ConnectionFactory is an autogenerated mock type for the ConnectionFactory type
type ConnectionFactory struct {
        mock.Mock
}

type ConnectionFactory_Expecter struct {
        mock *mock.Mock
}

func (_m *ConnectionFactory) EXPECT() *ConnectionFactory_Expecter <span class="cov0" title="0">{
        return &amp;ConnectionFactory_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateConnection provides a mock function with given fields: target
func (_m *ConnectionFactory) CreateConnection(target string) (*grpc.ClientConn, error) <span class="cov0" title="0">{
        ret := _m.Called(target)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateConnection")</span>
        }

        <span class="cov0" title="0">var r0 *grpc.ClientConn
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*grpc.ClientConn, error)); ok </span><span class="cov0" title="0">{
                return rf(target)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *grpc.ClientConn); ok </span><span class="cov0" title="0">{
                r0 = rf(target)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*grpc.ClientConn)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(target)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ConnectionFactory_CreateConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateConnection'
type ConnectionFactory_CreateConnection_Call struct {
        *mock.Call
}

// CreateConnection is a helper method to define mock.On call
//   - target string
func (_e *ConnectionFactory_Expecter) CreateConnection(target interface{}) *ConnectionFactory_CreateConnection_Call <span class="cov0" title="0">{
        return &amp;ConnectionFactory_CreateConnection_Call{Call: _e.mock.On("CreateConnection", target)}
}</span>

func (_c *ConnectionFactory_CreateConnection_Call) Run(run func(target string)) *ConnectionFactory_CreateConnection_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *ConnectionFactory_CreateConnection_Call) Return(_a0 *grpc.ClientConn, _a1 error) *ConnectionFactory_CreateConnection_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *ConnectionFactory_CreateConnection_Call) RunAndReturn(run func(string) (*grpc.ClientConn, error)) *ConnectionFactory_CreateConnection_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewConnectionFactory creates a new instance of ConnectionFactory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConnectionFactory(t interface {
        mock.TestingT
        Cleanup(func())
}) *ConnectionFactory <span class="cov0" title="0">{
        mock := &amp;ConnectionFactory{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        name "github.com/cirglo.com/dfs/pkg/name"
        mock "github.com/stretchr/testify/mock"

        proto "github.com/cirglo.com/dfs/pkg/proto"
)

// FileService is an autogenerated mock type for the FileService type
type FileService struct {
        mock.Mock
}

type FileService_Expecter struct {
        mock *mock.Mock
}

func (_m *FileService) EXPECT() *FileService_Expecter <span class="cov0" title="0">{
        return &amp;FileService_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateDir provides a mock function with given fields: p, path, perms
func (_m *FileService) CreateDir(p name.Principal, path string, perms name.Permissions) (name.FileInfo, error) <span class="cov0" title="0">{
        ret := _m.Called(p, path, perms)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateDir")</span>
        }

        <span class="cov0" title="0">var r0 name.FileInfo
        var r1 error
        if rf, ok := ret.Get(0).(func(name.Principal, string, name.Permissions) (name.FileInfo, error)); ok </span><span class="cov0" title="0">{
                return rf(p, path, perms)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(name.Principal, string, name.Permissions) name.FileInfo); ok </span><span class="cov0" title="0">{
                r0 = rf(p, path, perms)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(name.FileInfo)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(name.Principal, string, name.Permissions) error); ok </span><span class="cov0" title="0">{
                r1 = rf(p, path, perms)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// FileService_CreateDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDir'
type FileService_CreateDir_Call struct {
        *mock.Call
}

// CreateDir is a helper method to define mock.On call
//   - p name.Principal
//   - path string
//   - perms name.Permissions
func (_e *FileService_Expecter) CreateDir(p interface{}, path interface{}, perms interface{}) *FileService_CreateDir_Call <span class="cov0" title="0">{
        return &amp;FileService_CreateDir_Call{Call: _e.mock.On("CreateDir", p, path, perms)}
}</span>

func (_c *FileService_CreateDir_Call) Run(run func(p name.Principal, path string, perms name.Permissions)) *FileService_CreateDir_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(name.Principal), args[1].(string), args[2].(name.Permissions))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_CreateDir_Call) Return(_a0 name.FileInfo, _a1 error) *FileService_CreateDir_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *FileService_CreateDir_Call) RunAndReturn(run func(name.Principal, string, name.Permissions) (name.FileInfo, error)) *FileService_CreateDir_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateFile provides a mock function with given fields: p, path, perms
func (_m *FileService) CreateFile(p name.Principal, path string, perms name.Permissions) (name.FileInfo, error) <span class="cov0" title="0">{
        ret := _m.Called(p, path, perms)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateFile")</span>
        }

        <span class="cov0" title="0">var r0 name.FileInfo
        var r1 error
        if rf, ok := ret.Get(0).(func(name.Principal, string, name.Permissions) (name.FileInfo, error)); ok </span><span class="cov0" title="0">{
                return rf(p, path, perms)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(name.Principal, string, name.Permissions) name.FileInfo); ok </span><span class="cov0" title="0">{
                r0 = rf(p, path, perms)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(name.FileInfo)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(name.Principal, string, name.Permissions) error); ok </span><span class="cov0" title="0">{
                r1 = rf(p, path, perms)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// FileService_CreateFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFile'
type FileService_CreateFile_Call struct {
        *mock.Call
}

// CreateFile is a helper method to define mock.On call
//   - p name.Principal
//   - path string
//   - perms name.Permissions
func (_e *FileService_Expecter) CreateFile(p interface{}, path interface{}, perms interface{}) *FileService_CreateFile_Call <span class="cov0" title="0">{
        return &amp;FileService_CreateFile_Call{Call: _e.mock.On("CreateFile", p, path, perms)}
}</span>

func (_c *FileService_CreateFile_Call) Run(run func(p name.Principal, path string, perms name.Permissions)) *FileService_CreateFile_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(name.Principal), args[1].(string), args[2].(name.Permissions))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_CreateFile_Call) Return(_a0 name.FileInfo, _a1 error) *FileService_CreateFile_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *FileService_CreateFile_Call) RunAndReturn(run func(name.Principal, string, name.Permissions) (name.FileInfo, error)) *FileService_CreateFile_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteDir provides a mock function with given fields: p, path
func (_m *FileService) DeleteDir(p name.Principal, path string) error <span class="cov0" title="0">{
        ret := _m.Called(p, path)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteDir")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(name.Principal, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(p, path)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// FileService_DeleteDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDir'
type FileService_DeleteDir_Call struct {
        *mock.Call
}

// DeleteDir is a helper method to define mock.On call
//   - p name.Principal
//   - path string
func (_e *FileService_Expecter) DeleteDir(p interface{}, path interface{}) *FileService_DeleteDir_Call <span class="cov0" title="0">{
        return &amp;FileService_DeleteDir_Call{Call: _e.mock.On("DeleteDir", p, path)}
}</span>

func (_c *FileService_DeleteDir_Call) Run(run func(p name.Principal, path string)) *FileService_DeleteDir_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(name.Principal), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_DeleteDir_Call) Return(_a0 error) *FileService_DeleteDir_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *FileService_DeleteDir_Call) RunAndReturn(run func(name.Principal, string) error) *FileService_DeleteDir_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteFile provides a mock function with given fields: p, path
func (_m *FileService) DeleteFile(p name.Principal, path string) error <span class="cov0" title="0">{
        ret := _m.Called(p, path)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteFile")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(name.Principal, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(p, path)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// FileService_DeleteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFile'
type FileService_DeleteFile_Call struct {
        *mock.Call
}

// DeleteFile is a helper method to define mock.On call
//   - p name.Principal
//   - path string
func (_e *FileService_Expecter) DeleteFile(p interface{}, path interface{}) *FileService_DeleteFile_Call <span class="cov0" title="0">{
        return &amp;FileService_DeleteFile_Call{Call: _e.mock.On("DeleteFile", p, path)}
}</span>

func (_c *FileService_DeleteFile_Call) Run(run func(p name.Principal, path string)) *FileService_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(name.Principal), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_DeleteFile_Call) Return(_a0 error) *FileService_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *FileService_DeleteFile_Call) RunAndReturn(run func(name.Principal, string) error) *FileService_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetAllBlockInfos provides a mock function with no fields
func (_m *FileService) GetAllBlockInfos() ([]name.BlockInfo, error) <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAllBlockInfos")</span>
        }

        <span class="cov0" title="0">var r0 []name.BlockInfo
        var r1 error
        if rf, ok := ret.Get(0).(func() ([]name.BlockInfo, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func() []name.BlockInfo); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]name.BlockInfo)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// FileService_GetAllBlockInfos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllBlockInfos'
type FileService_GetAllBlockInfos_Call struct {
        *mock.Call
}

// GetAllBlockInfos is a helper method to define mock.On call
func (_e *FileService_Expecter) GetAllBlockInfos() *FileService_GetAllBlockInfos_Call <span class="cov0" title="0">{
        return &amp;FileService_GetAllBlockInfos_Call{Call: _e.mock.On("GetAllBlockInfos")}
}</span>

func (_c *FileService_GetAllBlockInfos_Call) Run(run func()) *FileService_GetAllBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_GetAllBlockInfos_Call) Return(_a0 []name.BlockInfo, _a1 error) *FileService_GetAllBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *FileService_GetAllBlockInfos_Call) RunAndReturn(run func() ([]name.BlockInfo, error)) *FileService_GetAllBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBlockInfos provides a mock function with given fields: p, path
func (_m *FileService) GetBlockInfos(p name.Principal, path string) ([]name.BlockInfo, error) <span class="cov0" title="0">{
        ret := _m.Called(p, path)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBlockInfos")</span>
        }

        <span class="cov0" title="0">var r0 []name.BlockInfo
        var r1 error
        if rf, ok := ret.Get(0).(func(name.Principal, string) ([]name.BlockInfo, error)); ok </span><span class="cov0" title="0">{
                return rf(p, path)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(name.Principal, string) []name.BlockInfo); ok </span><span class="cov0" title="0">{
                r0 = rf(p, path)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]name.BlockInfo)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(name.Principal, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(p, path)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// FileService_GetBlockInfos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockInfos'
type FileService_GetBlockInfos_Call struct {
        *mock.Call
}

// GetBlockInfos is a helper method to define mock.On call
//   - p name.Principal
//   - path string
func (_e *FileService_Expecter) GetBlockInfos(p interface{}, path interface{}) *FileService_GetBlockInfos_Call <span class="cov0" title="0">{
        return &amp;FileService_GetBlockInfos_Call{Call: _e.mock.On("GetBlockInfos", p, path)}
}</span>

func (_c *FileService_GetBlockInfos_Call) Run(run func(p name.Principal, path string)) *FileService_GetBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(name.Principal), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_GetBlockInfos_Call) Return(_a0 []name.BlockInfo, _a1 error) *FileService_GetBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *FileService_GetBlockInfos_Call) RunAndReturn(run func(name.Principal, string) ([]name.BlockInfo, error)) *FileService_GetBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// List provides a mock function with given fields: p, path
func (_m *FileService) List(p name.Principal, path string) ([]name.FileInfo, error) <span class="cov0" title="0">{
        ret := _m.Called(p, path)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for List")</span>
        }

        <span class="cov0" title="0">var r0 []name.FileInfo
        var r1 error
        if rf, ok := ret.Get(0).(func(name.Principal, string) ([]name.FileInfo, error)); ok </span><span class="cov0" title="0">{
                return rf(p, path)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(name.Principal, string) []name.FileInfo); ok </span><span class="cov0" title="0">{
                r0 = rf(p, path)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]name.FileInfo)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(name.Principal, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(p, path)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// FileService_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type FileService_List_Call struct {
        *mock.Call
}

// List is a helper method to define mock.On call
//   - p name.Principal
//   - path string
func (_e *FileService_Expecter) List(p interface{}, path interface{}) *FileService_List_Call <span class="cov0" title="0">{
        return &amp;FileService_List_Call{Call: _e.mock.On("List", p, path)}
}</span>

func (_c *FileService_List_Call) Run(run func(p name.Principal, path string)) *FileService_List_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(name.Principal), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_List_Call) Return(_a0 []name.FileInfo, _a1 error) *FileService_List_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *FileService_List_Call) RunAndReturn(run func(name.Principal, string) ([]name.FileInfo, error)) *FileService_List_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NodeRemoved provides a mock function with given fields: host
func (_m *FileService) NodeRemoved(host string) error <span class="cov0" title="0">{
        ret := _m.Called(host)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NodeRemoved")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(host)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// FileService_NodeRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NodeRemoved'
type FileService_NodeRemoved_Call struct {
        *mock.Call
}

// NodeRemoved is a helper method to define mock.On call
//   - host string
func (_e *FileService_Expecter) NodeRemoved(host interface{}) *FileService_NodeRemoved_Call <span class="cov0" title="0">{
        return &amp;FileService_NodeRemoved_Call{Call: _e.mock.On("NodeRemoved", host)}
}</span>

func (_c *FileService_NodeRemoved_Call) Run(run func(host string)) *FileService_NodeRemoved_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_NodeRemoved_Call) Return(_a0 error) *FileService_NodeRemoved_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *FileService_NodeRemoved_Call) RunAndReturn(run func(string) error) *FileService_NodeRemoved_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NotifyBlockAdded provides a mock function with given fields: n
func (_m *FileService) NotifyBlockAdded(n *proto.NotifyBlockAddedRequest) error <span class="cov0" title="0">{
        ret := _m.Called(n)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NotifyBlockAdded")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*proto.NotifyBlockAddedRequest) error); ok </span><span class="cov0" title="0">{
                r0 = rf(n)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// FileService_NotifyBlockAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyBlockAdded'
type FileService_NotifyBlockAdded_Call struct {
        *mock.Call
}

// NotifyBlockAdded is a helper method to define mock.On call
//   - n *proto.NotifyBlockAddedRequest
func (_e *FileService_Expecter) NotifyBlockAdded(n interface{}) *FileService_NotifyBlockAdded_Call <span class="cov0" title="0">{
        return &amp;FileService_NotifyBlockAdded_Call{Call: _e.mock.On("NotifyBlockAdded", n)}
}</span>

func (_c *FileService_NotifyBlockAdded_Call) Run(run func(n *proto.NotifyBlockAddedRequest)) *FileService_NotifyBlockAdded_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*proto.NotifyBlockAddedRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_NotifyBlockAdded_Call) Return(_a0 error) *FileService_NotifyBlockAdded_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *FileService_NotifyBlockAdded_Call) RunAndReturn(run func(*proto.NotifyBlockAddedRequest) error) *FileService_NotifyBlockAdded_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NotifyBlockPresent provides a mock function with given fields: n
func (_m *FileService) NotifyBlockPresent(n *proto.NotifyBlockPresentRequest) error <span class="cov0" title="0">{
        ret := _m.Called(n)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NotifyBlockPresent")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*proto.NotifyBlockPresentRequest) error); ok </span><span class="cov0" title="0">{
                r0 = rf(n)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// FileService_NotifyBlockPresent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyBlockPresent'
type FileService_NotifyBlockPresent_Call struct {
        *mock.Call
}

// NotifyBlockPresent is a helper method to define mock.On call
//   - n *proto.NotifyBlockPresentRequest
func (_e *FileService_Expecter) NotifyBlockPresent(n interface{}) *FileService_NotifyBlockPresent_Call <span class="cov0" title="0">{
        return &amp;FileService_NotifyBlockPresent_Call{Call: _e.mock.On("NotifyBlockPresent", n)}
}</span>

func (_c *FileService_NotifyBlockPresent_Call) Run(run func(n *proto.NotifyBlockPresentRequest)) *FileService_NotifyBlockPresent_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*proto.NotifyBlockPresentRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_NotifyBlockPresent_Call) Return(_a0 error) *FileService_NotifyBlockPresent_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *FileService_NotifyBlockPresent_Call) RunAndReturn(run func(*proto.NotifyBlockPresentRequest) error) *FileService_NotifyBlockPresent_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NotifyBlockRemoved provides a mock function with given fields: n
func (_m *FileService) NotifyBlockRemoved(n *proto.NotifyBlockRemovedRequest) error <span class="cov0" title="0">{
        ret := _m.Called(n)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NotifyBlockRemoved")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*proto.NotifyBlockRemovedRequest) error); ok </span><span class="cov0" title="0">{
                r0 = rf(n)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// FileService_NotifyBlockRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyBlockRemoved'
type FileService_NotifyBlockRemoved_Call struct {
        *mock.Call
}

// NotifyBlockRemoved is a helper method to define mock.On call
//   - n *proto.NotifyBlockRemovedRequest
func (_e *FileService_Expecter) NotifyBlockRemoved(n interface{}) *FileService_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        return &amp;FileService_NotifyBlockRemoved_Call{Call: _e.mock.On("NotifyBlockRemoved", n)}
}</span>

func (_c *FileService_NotifyBlockRemoved_Call) Run(run func(n *proto.NotifyBlockRemovedRequest)) *FileService_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*proto.NotifyBlockRemovedRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_NotifyBlockRemoved_Call) Return(_a0 error) *FileService_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *FileService_NotifyBlockRemoved_Call) RunAndReturn(run func(*proto.NotifyBlockRemovedRequest) error) *FileService_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Stat provides a mock function with given fields: p, path
func (_m *FileService) Stat(p name.Principal, path string) (name.FileInfo, error) <span class="cov0" title="0">{
        ret := _m.Called(p, path)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Stat")</span>
        }

        <span class="cov0" title="0">var r0 name.FileInfo
        var r1 error
        if rf, ok := ret.Get(0).(func(name.Principal, string) (name.FileInfo, error)); ok </span><span class="cov0" title="0">{
                return rf(p, path)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(name.Principal, string) name.FileInfo); ok </span><span class="cov0" title="0">{
                r0 = rf(p, path)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(name.FileInfo)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(name.Principal, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(p, path)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// FileService_Stat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stat'
type FileService_Stat_Call struct {
        *mock.Call
}

// Stat is a helper method to define mock.On call
//   - p name.Principal
//   - path string
func (_e *FileService_Expecter) Stat(p interface{}, path interface{}) *FileService_Stat_Call <span class="cov0" title="0">{
        return &amp;FileService_Stat_Call{Call: _e.mock.On("Stat", p, path)}
}</span>

func (_c *FileService_Stat_Call) Run(run func(p name.Principal, path string)) *FileService_Stat_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(name.Principal), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *FileService_Stat_Call) Return(_a0 name.FileInfo, _a1 error) *FileService_Stat_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *FileService_Stat_Call) RunAndReturn(run func(name.Principal, string) (name.FileInfo, error)) *FileService_Stat_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewFileService creates a new instance of FileService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFileService(t interface {
        mock.TestingT
        Cleanup(func())
}) *FileService <span class="cov0" title="0">{
        mock := &amp;FileService{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        mock "github.com/stretchr/testify/mock"

        time "time"
)

// HealingService is an autogenerated mock type for the HealingService type
type HealingService struct {
        mock.Mock
}

type HealingService_Expecter struct {
        mock *mock.Mock
}

func (_m *HealingService) EXPECT() *HealingService_Expecter <span class="cov0" title="0">{
        return &amp;HealingService_Expecter{mock: &amp;_m.Mock}
}</span>

// Heal provides a mock function with given fields: since
func (_m *HealingService) Heal(since time.Time) error <span class="cov0" title="0">{
        ret := _m.Called(since)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Heal")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(time.Time) error); ok </span><span class="cov0" title="0">{
                r0 = rf(since)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// HealingService_Heal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Heal'
type HealingService_Heal_Call struct {
        *mock.Call
}

// Heal is a helper method to define mock.On call
//   - since time.Time
func (_e *HealingService_Expecter) Heal(since interface{}) *HealingService_Heal_Call <span class="cov0" title="0">{
        return &amp;HealingService_Heal_Call{Call: _e.mock.On("Heal", since)}
}</span>

func (_c *HealingService_Heal_Call) Run(run func(since time.Time)) *HealingService_Heal_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(time.Time))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *HealingService_Heal_Call) Return(_a0 error) *HealingService_Heal_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *HealingService_Heal_Call) RunAndReturn(run func(time.Time) error) *HealingService_Heal_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NotifyNodeAlive provides a mock function with given fields: host, at
func (_m *HealingService) NotifyNodeAlive(host string, at time.Time) <span class="cov0" title="0">{
        _m.Called(host, at)
}</span>

// HealingService_NotifyNodeAlive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyNodeAlive'
type HealingService_NotifyNodeAlive_Call struct {
        *mock.Call
}

// NotifyNodeAlive is a helper method to define mock.On call
//   - host string
//   - at time.Time
func (_e *HealingService_Expecter) NotifyNodeAlive(host interface{}, at interface{}) *HealingService_NotifyNodeAlive_Call <span class="cov0" title="0">{
        return &amp;HealingService_NotifyNodeAlive_Call{Call: _e.mock.On("NotifyNodeAlive", host, at)}
}</span>

func (_c *HealingService_NotifyNodeAlive_Call) Run(run func(host string, at time.Time)) *HealingService_NotifyNodeAlive_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(time.Time))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *HealingService_NotifyNodeAlive_Call) Return() *HealingService_NotifyNodeAlive_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *HealingService_NotifyNodeAlive_Call) RunAndReturn(run func(string, time.Time)) *HealingService_NotifyNodeAlive_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// NewHealingService creates a new instance of HealingService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHealingService(t interface {
        mock.TestingT
        Cleanup(func())
}) *HealingService <span class="cov0" title="0">{
        mock := &amp;HealingService{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        grpc "google.golang.org/grpc"

        mock "github.com/stretchr/testify/mock"

        proto "github.com/cirglo.com/dfs/pkg/proto"
)

// NameClient is an autogenerated mock type for the NameClient type
type NameClient struct {
        mock.Mock
}

type NameClient_Expecter struct {
        mock *mock.Mock
}

func (_m *NameClient) EXPECT() *NameClient_Expecter <span class="cov0" title="0">{
        return &amp;NameClient_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateDir provides a mock function with given fields: ctx, in, opts
func (_m *NameClient) CreateDir(ctx context.Context, in *proto.CreateDirRequest, opts ...grpc.CallOption) (*proto.CreateDirResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateDir")</span>
        }

        <span class="cov0" title="0">var r0 *proto.CreateDirResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.CreateDirRequest, ...grpc.CallOption) (*proto.CreateDirResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.CreateDirRequest, ...grpc.CallOption) *proto.CreateDirResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.CreateDirResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.CreateDirRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameClient_CreateDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDir'
type NameClient_CreateDir_Call struct {
        *mock.Call
}

// CreateDir is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.CreateDirRequest
//   - opts ...grpc.CallOption
func (_e *NameClient_Expecter) CreateDir(ctx interface{}, in interface{}, opts ...interface{}) *NameClient_CreateDir_Call <span class="cov0" title="0">{
        return &amp;NameClient_CreateDir_Call{Call: _e.mock.On("CreateDir",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NameClient_CreateDir_Call) Run(run func(ctx context.Context, in *proto.CreateDirRequest, opts ...grpc.CallOption)) *NameClient_CreateDir_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.CreateDirRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameClient_CreateDir_Call) Return(_a0 *proto.CreateDirResponse, _a1 error) *NameClient_CreateDir_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameClient_CreateDir_Call) RunAndReturn(run func(context.Context, *proto.CreateDirRequest, ...grpc.CallOption) (*proto.CreateDirResponse, error)) *NameClient_CreateDir_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateFile provides a mock function with given fields: ctx, in, opts
func (_m *NameClient) CreateFile(ctx context.Context, in *proto.CreateFileRequest, opts ...grpc.CallOption) (*proto.CreateFileResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateFile")</span>
        }

        <span class="cov0" title="0">var r0 *proto.CreateFileResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.CreateFileRequest, ...grpc.CallOption) (*proto.CreateFileResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.CreateFileRequest, ...grpc.CallOption) *proto.CreateFileResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.CreateFileResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.CreateFileRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameClient_CreateFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFile'
type NameClient_CreateFile_Call struct {
        *mock.Call
}

// CreateFile is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.CreateFileRequest
//   - opts ...grpc.CallOption
func (_e *NameClient_Expecter) CreateFile(ctx interface{}, in interface{}, opts ...interface{}) *NameClient_CreateFile_Call <span class="cov0" title="0">{
        return &amp;NameClient_CreateFile_Call{Call: _e.mock.On("CreateFile",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NameClient_CreateFile_Call) Run(run func(ctx context.Context, in *proto.CreateFileRequest, opts ...grpc.CallOption)) *NameClient_CreateFile_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.CreateFileRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameClient_CreateFile_Call) Return(_a0 *proto.CreateFileResponse, _a1 error) *NameClient_CreateFile_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameClient_CreateFile_Call) RunAndReturn(run func(context.Context, *proto.CreateFileRequest, ...grpc.CallOption) (*proto.CreateFileResponse, error)) *NameClient_CreateFile_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteDir provides a mock function with given fields: ctx, in, opts
func (_m *NameClient) DeleteDir(ctx context.Context, in *proto.DeleteDirRequest, opts ...grpc.CallOption) (*proto.DeleteDirResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteDir")</span>
        }

        <span class="cov0" title="0">var r0 *proto.DeleteDirResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteDirRequest, ...grpc.CallOption) (*proto.DeleteDirResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteDirRequest, ...grpc.CallOption) *proto.DeleteDirResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.DeleteDirResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.DeleteDirRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameClient_DeleteDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDir'
type NameClient_DeleteDir_Call struct {
        *mock.Call
}

// DeleteDir is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.DeleteDirRequest
//   - opts ...grpc.CallOption
func (_e *NameClient_Expecter) DeleteDir(ctx interface{}, in interface{}, opts ...interface{}) *NameClient_DeleteDir_Call <span class="cov0" title="0">{
        return &amp;NameClient_DeleteDir_Call{Call: _e.mock.On("DeleteDir",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NameClient_DeleteDir_Call) Run(run func(ctx context.Context, in *proto.DeleteDirRequest, opts ...grpc.CallOption)) *NameClient_DeleteDir_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.DeleteDirRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameClient_DeleteDir_Call) Return(_a0 *proto.DeleteDirResponse, _a1 error) *NameClient_DeleteDir_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameClient_DeleteDir_Call) RunAndReturn(run func(context.Context, *proto.DeleteDirRequest, ...grpc.CallOption) (*proto.DeleteDirResponse, error)) *NameClient_DeleteDir_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteFile provides a mock function with given fields: ctx, in, opts
func (_m *NameClient) DeleteFile(ctx context.Context, in *proto.DeleteFileRequest, opts ...grpc.CallOption) (*proto.DeleteFileResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteFile")</span>
        }

        <span class="cov0" title="0">var r0 *proto.DeleteFileResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteFileRequest, ...grpc.CallOption) (*proto.DeleteFileResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteFileRequest, ...grpc.CallOption) *proto.DeleteFileResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.DeleteFileResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.DeleteFileRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameClient_DeleteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFile'
type NameClient_DeleteFile_Call struct {
        *mock.Call
}

// DeleteFile is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.DeleteFileRequest
//   - opts ...grpc.CallOption
func (_e *NameClient_Expecter) DeleteFile(ctx interface{}, in interface{}, opts ...interface{}) *NameClient_DeleteFile_Call <span class="cov0" title="0">{
        return &amp;NameClient_DeleteFile_Call{Call: _e.mock.On("DeleteFile",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NameClient_DeleteFile_Call) Run(run func(ctx context.Context, in *proto.DeleteFileRequest, opts ...grpc.CallOption)) *NameClient_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.DeleteFileRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameClient_DeleteFile_Call) Return(_a0 *proto.DeleteFileResponse, _a1 error) *NameClient_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameClient_DeleteFile_Call) RunAndReturn(run func(context.Context, *proto.DeleteFileRequest, ...grpc.CallOption) (*proto.DeleteFileResponse, error)) *NameClient_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// List provides a mock function with given fields: ctx, in, opts
func (_m *NameClient) List(ctx context.Context, in *proto.ListRequest, opts ...grpc.CallOption) (*proto.ListResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for List")</span>
        }

        <span class="cov0" title="0">var r0 *proto.ListResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.ListRequest, ...grpc.CallOption) (*proto.ListResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.ListRequest, ...grpc.CallOption) *proto.ListResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.ListResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.ListRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameClient_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type NameClient_List_Call struct {
        *mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.ListRequest
//   - opts ...grpc.CallOption
func (_e *NameClient_Expecter) List(ctx interface{}, in interface{}, opts ...interface{}) *NameClient_List_Call <span class="cov0" title="0">{
        return &amp;NameClient_List_Call{Call: _e.mock.On("List",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NameClient_List_Call) Run(run func(ctx context.Context, in *proto.ListRequest, opts ...grpc.CallOption)) *NameClient_List_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.ListRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameClient_List_Call) Return(_a0 *proto.ListResponse, _a1 error) *NameClient_List_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameClient_List_Call) RunAndReturn(run func(context.Context, *proto.ListRequest, ...grpc.CallOption) (*proto.ListResponse, error)) *NameClient_List_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Login provides a mock function with given fields: ctx, in, opts
func (_m *NameClient) Login(ctx context.Context, in *proto.LoginRequest, opts ...grpc.CallOption) (*proto.LoginResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Login")</span>
        }

        <span class="cov0" title="0">var r0 *proto.LoginResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.LoginRequest, ...grpc.CallOption) (*proto.LoginResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.LoginRequest, ...grpc.CallOption) *proto.LoginResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.LoginResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.LoginRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameClient_Login_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Login'
type NameClient_Login_Call struct {
        *mock.Call
}

// Login is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.LoginRequest
//   - opts ...grpc.CallOption
func (_e *NameClient_Expecter) Login(ctx interface{}, in interface{}, opts ...interface{}) *NameClient_Login_Call <span class="cov0" title="0">{
        return &amp;NameClient_Login_Call{Call: _e.mock.On("Login",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NameClient_Login_Call) Run(run func(ctx context.Context, in *proto.LoginRequest, opts ...grpc.CallOption)) *NameClient_Login_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.LoginRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameClient_Login_Call) Return(_a0 *proto.LoginResponse, _a1 error) *NameClient_Login_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameClient_Login_Call) RunAndReturn(run func(context.Context, *proto.LoginRequest, ...grpc.CallOption) (*proto.LoginResponse, error)) *NameClient_Login_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Logout provides a mock function with given fields: ctx, in, opts
func (_m *NameClient) Logout(ctx context.Context, in *proto.LogoutRequest, opts ...grpc.CallOption) (*proto.LogoutResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Logout")</span>
        }

        <span class="cov0" title="0">var r0 *proto.LogoutResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.LogoutRequest, ...grpc.CallOption) (*proto.LogoutResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.LogoutRequest, ...grpc.CallOption) *proto.LogoutResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.LogoutResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.LogoutRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameClient_Logout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logout'
type NameClient_Logout_Call struct {
        *mock.Call
}

// Logout is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.LogoutRequest
//   - opts ...grpc.CallOption
func (_e *NameClient_Expecter) Logout(ctx interface{}, in interface{}, opts ...interface{}) *NameClient_Logout_Call <span class="cov0" title="0">{
        return &amp;NameClient_Logout_Call{Call: _e.mock.On("Logout",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NameClient_Logout_Call) Run(run func(ctx context.Context, in *proto.LogoutRequest, opts ...grpc.CallOption)) *NameClient_Logout_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.LogoutRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameClient_Logout_Call) Return(_a0 *proto.LogoutResponse, _a1 error) *NameClient_Logout_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameClient_Logout_Call) RunAndReturn(run func(context.Context, *proto.LogoutRequest, ...grpc.CallOption) (*proto.LogoutResponse, error)) *NameClient_Logout_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Stat provides a mock function with given fields: ctx, in, opts
func (_m *NameClient) Stat(ctx context.Context, in *proto.StatRequest, opts ...grpc.CallOption) (*proto.StatResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Stat")</span>
        }

        <span class="cov0" title="0">var r0 *proto.StatResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.StatRequest, ...grpc.CallOption) (*proto.StatResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.StatRequest, ...grpc.CallOption) *proto.StatResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.StatResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.StatRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameClient_Stat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stat'
type NameClient_Stat_Call struct {
        *mock.Call
}

// Stat is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.StatRequest
//   - opts ...grpc.CallOption
func (_e *NameClient_Expecter) Stat(ctx interface{}, in interface{}, opts ...interface{}) *NameClient_Stat_Call <span class="cov0" title="0">{
        return &amp;NameClient_Stat_Call{Call: _e.mock.On("Stat",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NameClient_Stat_Call) Run(run func(ctx context.Context, in *proto.StatRequest, opts ...grpc.CallOption)) *NameClient_Stat_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.StatRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameClient_Stat_Call) Return(_a0 *proto.StatResponse, _a1 error) *NameClient_Stat_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameClient_Stat_Call) RunAndReturn(run func(context.Context, *proto.StatRequest, ...grpc.CallOption) (*proto.StatResponse, error)) *NameClient_Stat_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewNameClient creates a new instance of NameClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNameClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *NameClient <span class="cov0" title="0">{
        mock := &amp;NameClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        proto "github.com/cirglo.com/dfs/pkg/proto"
        mock "github.com/stretchr/testify/mock"
)

// NameServer is an autogenerated mock type for the NameServer type
type NameServer struct {
        mock.Mock
}

type NameServer_Expecter struct {
        mock *mock.Mock
}

func (_m *NameServer) EXPECT() *NameServer_Expecter <span class="cov0" title="0">{
        return &amp;NameServer_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateDir provides a mock function with given fields: _a0, _a1
func (_m *NameServer) CreateDir(_a0 context.Context, _a1 *proto.CreateDirRequest) (*proto.CreateDirResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateDir")</span>
        }

        <span class="cov0" title="0">var r0 *proto.CreateDirResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.CreateDirRequest) (*proto.CreateDirResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.CreateDirRequest) *proto.CreateDirResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.CreateDirResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.CreateDirRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameServer_CreateDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDir'
type NameServer_CreateDir_Call struct {
        *mock.Call
}

// CreateDir is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.CreateDirRequest
func (_e *NameServer_Expecter) CreateDir(_a0 interface{}, _a1 interface{}) *NameServer_CreateDir_Call <span class="cov0" title="0">{
        return &amp;NameServer_CreateDir_Call{Call: _e.mock.On("CreateDir", _a0, _a1)}
}</span>

func (_c *NameServer_CreateDir_Call) Run(run func(_a0 context.Context, _a1 *proto.CreateDirRequest)) *NameServer_CreateDir_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.CreateDirRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameServer_CreateDir_Call) Return(_a0 *proto.CreateDirResponse, _a1 error) *NameServer_CreateDir_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameServer_CreateDir_Call) RunAndReturn(run func(context.Context, *proto.CreateDirRequest) (*proto.CreateDirResponse, error)) *NameServer_CreateDir_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateFile provides a mock function with given fields: _a0, _a1
func (_m *NameServer) CreateFile(_a0 context.Context, _a1 *proto.CreateFileRequest) (*proto.CreateFileResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateFile")</span>
        }

        <span class="cov0" title="0">var r0 *proto.CreateFileResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.CreateFileRequest) (*proto.CreateFileResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.CreateFileRequest) *proto.CreateFileResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.CreateFileResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.CreateFileRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameServer_CreateFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFile'
type NameServer_CreateFile_Call struct {
        *mock.Call
}

// CreateFile is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.CreateFileRequest
func (_e *NameServer_Expecter) CreateFile(_a0 interface{}, _a1 interface{}) *NameServer_CreateFile_Call <span class="cov0" title="0">{
        return &amp;NameServer_CreateFile_Call{Call: _e.mock.On("CreateFile", _a0, _a1)}
}</span>

func (_c *NameServer_CreateFile_Call) Run(run func(_a0 context.Context, _a1 *proto.CreateFileRequest)) *NameServer_CreateFile_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.CreateFileRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameServer_CreateFile_Call) Return(_a0 *proto.CreateFileResponse, _a1 error) *NameServer_CreateFile_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameServer_CreateFile_Call) RunAndReturn(run func(context.Context, *proto.CreateFileRequest) (*proto.CreateFileResponse, error)) *NameServer_CreateFile_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteDir provides a mock function with given fields: _a0, _a1
func (_m *NameServer) DeleteDir(_a0 context.Context, _a1 *proto.DeleteDirRequest) (*proto.DeleteDirResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteDir")</span>
        }

        <span class="cov0" title="0">var r0 *proto.DeleteDirResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteDirRequest) (*proto.DeleteDirResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteDirRequest) *proto.DeleteDirResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.DeleteDirResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.DeleteDirRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameServer_DeleteDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDir'
type NameServer_DeleteDir_Call struct {
        *mock.Call
}

// DeleteDir is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.DeleteDirRequest
func (_e *NameServer_Expecter) DeleteDir(_a0 interface{}, _a1 interface{}) *NameServer_DeleteDir_Call <span class="cov0" title="0">{
        return &amp;NameServer_DeleteDir_Call{Call: _e.mock.On("DeleteDir", _a0, _a1)}
}</span>

func (_c *NameServer_DeleteDir_Call) Run(run func(_a0 context.Context, _a1 *proto.DeleteDirRequest)) *NameServer_DeleteDir_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.DeleteDirRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameServer_DeleteDir_Call) Return(_a0 *proto.DeleteDirResponse, _a1 error) *NameServer_DeleteDir_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameServer_DeleteDir_Call) RunAndReturn(run func(context.Context, *proto.DeleteDirRequest) (*proto.DeleteDirResponse, error)) *NameServer_DeleteDir_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteFile provides a mock function with given fields: _a0, _a1
func (_m *NameServer) DeleteFile(_a0 context.Context, _a1 *proto.DeleteFileRequest) (*proto.DeleteFileResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteFile")</span>
        }

        <span class="cov0" title="0">var r0 *proto.DeleteFileResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteFileRequest) (*proto.DeleteFileResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteFileRequest) *proto.DeleteFileResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.DeleteFileResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.DeleteFileRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameServer_DeleteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFile'
type NameServer_DeleteFile_Call struct {
        *mock.Call
}

// DeleteFile is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.DeleteFileRequest
func (_e *NameServer_Expecter) DeleteFile(_a0 interface{}, _a1 interface{}) *NameServer_DeleteFile_Call <span class="cov0" title="0">{
        return &amp;NameServer_DeleteFile_Call{Call: _e.mock.On("DeleteFile", _a0, _a1)}
}</span>

func (_c *NameServer_DeleteFile_Call) Run(run func(_a0 context.Context, _a1 *proto.DeleteFileRequest)) *NameServer_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.DeleteFileRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameServer_DeleteFile_Call) Return(_a0 *proto.DeleteFileResponse, _a1 error) *NameServer_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameServer_DeleteFile_Call) RunAndReturn(run func(context.Context, *proto.DeleteFileRequest) (*proto.DeleteFileResponse, error)) *NameServer_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// List provides a mock function with given fields: _a0, _a1
func (_m *NameServer) List(_a0 context.Context, _a1 *proto.ListRequest) (*proto.ListResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for List")</span>
        }

        <span class="cov0" title="0">var r0 *proto.ListResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.ListRequest) (*proto.ListResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.ListRequest) *proto.ListResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.ListResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.ListRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameServer_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type NameServer_List_Call struct {
        *mock.Call
}

// List is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.ListRequest
func (_e *NameServer_Expecter) List(_a0 interface{}, _a1 interface{}) *NameServer_List_Call <span class="cov0" title="0">{
        return &amp;NameServer_List_Call{Call: _e.mock.On("List", _a0, _a1)}
}</span>

func (_c *NameServer_List_Call) Run(run func(_a0 context.Context, _a1 *proto.ListRequest)) *NameServer_List_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.ListRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameServer_List_Call) Return(_a0 *proto.ListResponse, _a1 error) *NameServer_List_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameServer_List_Call) RunAndReturn(run func(context.Context, *proto.ListRequest) (*proto.ListResponse, error)) *NameServer_List_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Login provides a mock function with given fields: _a0, _a1
func (_m *NameServer) Login(_a0 context.Context, _a1 *proto.LoginRequest) (*proto.LoginResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Login")</span>
        }

        <span class="cov0" title="0">var r0 *proto.LoginResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.LoginRequest) (*proto.LoginResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.LoginRequest) *proto.LoginResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.LoginResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.LoginRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameServer_Login_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Login'
type NameServer_Login_Call struct {
        *mock.Call
}

// Login is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.LoginRequest
func (_e *NameServer_Expecter) Login(_a0 interface{}, _a1 interface{}) *NameServer_Login_Call <span class="cov0" title="0">{
        return &amp;NameServer_Login_Call{Call: _e.mock.On("Login", _a0, _a1)}
}</span>

func (_c *NameServer_Login_Call) Run(run func(_a0 context.Context, _a1 *proto.LoginRequest)) *NameServer_Login_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.LoginRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameServer_Login_Call) Return(_a0 *proto.LoginResponse, _a1 error) *NameServer_Login_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameServer_Login_Call) RunAndReturn(run func(context.Context, *proto.LoginRequest) (*proto.LoginResponse, error)) *NameServer_Login_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Logout provides a mock function with given fields: _a0, _a1
func (_m *NameServer) Logout(_a0 context.Context, _a1 *proto.LogoutRequest) (*proto.LogoutResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Logout")</span>
        }

        <span class="cov0" title="0">var r0 *proto.LogoutResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.LogoutRequest) (*proto.LogoutResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.LogoutRequest) *proto.LogoutResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.LogoutResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.LogoutRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameServer_Logout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logout'
type NameServer_Logout_Call struct {
        *mock.Call
}

// Logout is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.LogoutRequest
func (_e *NameServer_Expecter) Logout(_a0 interface{}, _a1 interface{}) *NameServer_Logout_Call <span class="cov0" title="0">{
        return &amp;NameServer_Logout_Call{Call: _e.mock.On("Logout", _a0, _a1)}
}</span>

func (_c *NameServer_Logout_Call) Run(run func(_a0 context.Context, _a1 *proto.LogoutRequest)) *NameServer_Logout_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.LogoutRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameServer_Logout_Call) Return(_a0 *proto.LogoutResponse, _a1 error) *NameServer_Logout_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameServer_Logout_Call) RunAndReturn(run func(context.Context, *proto.LogoutRequest) (*proto.LogoutResponse, error)) *NameServer_Logout_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Stat provides a mock function with given fields: _a0, _a1
func (_m *NameServer) Stat(_a0 context.Context, _a1 *proto.StatRequest) (*proto.StatResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Stat")</span>
        }

        <span class="cov0" title="0">var r0 *proto.StatResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.StatRequest) (*proto.StatResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.StatRequest) *proto.StatResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.StatResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.StatRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NameServer_Stat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stat'
type NameServer_Stat_Call struct {
        *mock.Call
}

// Stat is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.StatRequest
func (_e *NameServer_Expecter) Stat(_a0 interface{}, _a1 interface{}) *NameServer_Stat_Call <span class="cov0" title="0">{
        return &amp;NameServer_Stat_Call{Call: _e.mock.On("Stat", _a0, _a1)}
}</span>

func (_c *NameServer_Stat_Call) Run(run func(_a0 context.Context, _a1 *proto.StatRequest)) *NameServer_Stat_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.StatRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameServer_Stat_Call) Return(_a0 *proto.StatResponse, _a1 error) *NameServer_Stat_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NameServer_Stat_Call) RunAndReturn(run func(context.Context, *proto.StatRequest) (*proto.StatResponse, error)) *NameServer_Stat_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// mustEmbedUnimplementedNameServer provides a mock function with no fields
func (_m *NameServer) mustEmbedUnimplementedNameServer() <span class="cov0" title="0">{
        _m.Called()
}</span>

// NameServer_mustEmbedUnimplementedNameServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'mustEmbedUnimplementedNameServer'
type NameServer_mustEmbedUnimplementedNameServer_Call struct {
        *mock.Call
}

// mustEmbedUnimplementedNameServer is a helper method to define mock.On call
func (_e *NameServer_Expecter) mustEmbedUnimplementedNameServer() *NameServer_mustEmbedUnimplementedNameServer_Call <span class="cov0" title="0">{
        return &amp;NameServer_mustEmbedUnimplementedNameServer_Call{Call: _e.mock.On("mustEmbedUnimplementedNameServer")}
}</span>

func (_c *NameServer_mustEmbedUnimplementedNameServer_Call) Run(run func()) *NameServer_mustEmbedUnimplementedNameServer_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NameServer_mustEmbedUnimplementedNameServer_Call) Return() *NameServer_mustEmbedUnimplementedNameServer_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *NameServer_mustEmbedUnimplementedNameServer_Call) RunAndReturn(run func()) *NameServer_mustEmbedUnimplementedNameServer_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// NewNameServer creates a new instance of NameServer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNameServer(t interface {
        mock.TestingT
        Cleanup(func())
}) *NameServer <span class="cov0" title="0">{
        mock := &amp;NameServer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        grpc "google.golang.org/grpc"

        mock "github.com/stretchr/testify/mock"

        proto "github.com/cirglo.com/dfs/pkg/proto"
)

// NodeClient is an autogenerated mock type for the NodeClient type
type NodeClient struct {
        mock.Mock
}

type NodeClient_Expecter struct {
        mock *mock.Mock
}

func (_m *NodeClient) EXPECT() *NodeClient_Expecter <span class="cov0" title="0">{
        return &amp;NodeClient_Expecter{mock: &amp;_m.Mock}
}</span>

// CopyBlock provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) CopyBlock(ctx context.Context, in *proto.CopyBlockRequest, opts ...grpc.CallOption) (*proto.CopyBlockResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CopyBlock")</span>
        }

        <span class="cov0" title="0">var r0 *proto.CopyBlockResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.CopyBlockRequest, ...grpc.CallOption) (*proto.CopyBlockResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.CopyBlockRequest, ...grpc.CallOption) *proto.CopyBlockResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.CopyBlockResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.CopyBlockRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeClient_CopyBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyBlock'
type NodeClient_CopyBlock_Call struct {
        *mock.Call
}

// CopyBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.CopyBlockRequest
//   - opts ...grpc.CallOption
func (_e *NodeClient_Expecter) CopyBlock(ctx interface{}, in interface{}, opts ...interface{}) *NodeClient_CopyBlock_Call <span class="cov0" title="0">{
        return &amp;NodeClient_CopyBlock_Call{Call: _e.mock.On("CopyBlock",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NodeClient_CopyBlock_Call) Run(run func(ctx context.Context, in *proto.CopyBlockRequest, opts ...grpc.CallOption)) *NodeClient_CopyBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.CopyBlockRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeClient_CopyBlock_Call) Return(_a0 *proto.CopyBlockResponse, _a1 error) *NodeClient_CopyBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeClient_CopyBlock_Call) RunAndReturn(run func(context.Context, *proto.CopyBlockRequest, ...grpc.CallOption) (*proto.CopyBlockResponse, error)) *NodeClient_CopyBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteBlock provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) DeleteBlock(ctx context.Context, in *proto.DeleteBlockRequest, opts ...grpc.CallOption) (*proto.DeleteBlockResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteBlock")</span>
        }

        <span class="cov0" title="0">var r0 *proto.DeleteBlockResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteBlockRequest, ...grpc.CallOption) (*proto.DeleteBlockResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteBlockRequest, ...grpc.CallOption) *proto.DeleteBlockResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.DeleteBlockResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.DeleteBlockRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeClient_DeleteBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBlock'
type NodeClient_DeleteBlock_Call struct {
        *mock.Call
}

// DeleteBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.DeleteBlockRequest
//   - opts ...grpc.CallOption
func (_e *NodeClient_Expecter) DeleteBlock(ctx interface{}, in interface{}, opts ...interface{}) *NodeClient_DeleteBlock_Call <span class="cov0" title="0">{
        return &amp;NodeClient_DeleteBlock_Call{Call: _e.mock.On("DeleteBlock",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NodeClient_DeleteBlock_Call) Run(run func(ctx context.Context, in *proto.DeleteBlockRequest, opts ...grpc.CallOption)) *NodeClient_DeleteBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.DeleteBlockRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeClient_DeleteBlock_Call) Return(_a0 *proto.DeleteBlockResponse, _a1 error) *NodeClient_DeleteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeClient_DeleteBlock_Call) RunAndReturn(run func(context.Context, *proto.DeleteBlockRequest, ...grpc.CallOption) (*proto.DeleteBlockResponse, error)) *NodeClient_DeleteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBlock provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) GetBlock(ctx context.Context, in *proto.GetBlockRequest, opts ...grpc.CallOption) (*proto.GetBlockResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBlock")</span>
        }

        <span class="cov0" title="0">var r0 *proto.GetBlockResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockRequest, ...grpc.CallOption) (*proto.GetBlockResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockRequest, ...grpc.CallOption) *proto.GetBlockResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.GetBlockResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.GetBlockRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeClient_GetBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlock'
type NodeClient_GetBlock_Call struct {
        *mock.Call
}

// GetBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.GetBlockRequest
//   - opts ...grpc.CallOption
func (_e *NodeClient_Expecter) GetBlock(ctx interface{}, in interface{}, opts ...interface{}) *NodeClient_GetBlock_Call <span class="cov0" title="0">{
        return &amp;NodeClient_GetBlock_Call{Call: _e.mock.On("GetBlock",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NodeClient_GetBlock_Call) Run(run func(ctx context.Context, in *proto.GetBlockRequest, opts ...grpc.CallOption)) *NodeClient_GetBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.GetBlockRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeClient_GetBlock_Call) Return(_a0 *proto.GetBlockResponse, _a1 error) *NodeClient_GetBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeClient_GetBlock_Call) RunAndReturn(run func(context.Context, *proto.GetBlockRequest, ...grpc.CallOption) (*proto.GetBlockResponse, error)) *NodeClient_GetBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBlockInfo provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) GetBlockInfo(ctx context.Context, in *proto.GetBlockInfoRequest, opts ...grpc.CallOption) (*proto.GetBlockInfoResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBlockInfo")</span>
        }

        <span class="cov0" title="0">var r0 *proto.GetBlockInfoResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockInfoRequest, ...grpc.CallOption) (*proto.GetBlockInfoResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockInfoRequest, ...grpc.CallOption) *proto.GetBlockInfoResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.GetBlockInfoResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.GetBlockInfoRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeClient_GetBlockInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockInfo'
type NodeClient_GetBlockInfo_Call struct {
        *mock.Call
}

// GetBlockInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.GetBlockInfoRequest
//   - opts ...grpc.CallOption
func (_e *NodeClient_Expecter) GetBlockInfo(ctx interface{}, in interface{}, opts ...interface{}) *NodeClient_GetBlockInfo_Call <span class="cov0" title="0">{
        return &amp;NodeClient_GetBlockInfo_Call{Call: _e.mock.On("GetBlockInfo",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NodeClient_GetBlockInfo_Call) Run(run func(ctx context.Context, in *proto.GetBlockInfoRequest, opts ...grpc.CallOption)) *NodeClient_GetBlockInfo_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.GetBlockInfoRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeClient_GetBlockInfo_Call) Return(_a0 *proto.GetBlockInfoResponse, _a1 error) *NodeClient_GetBlockInfo_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeClient_GetBlockInfo_Call) RunAndReturn(run func(context.Context, *proto.GetBlockInfoRequest, ...grpc.CallOption) (*proto.GetBlockInfoResponse, error)) *NodeClient_GetBlockInfo_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBlockInfos provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) GetBlockInfos(ctx context.Context, in *proto.GetBlockInfosRequest, opts ...grpc.CallOption) (*proto.GetBlockInfosResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBlockInfos")</span>
        }

        <span class="cov0" title="0">var r0 *proto.GetBlockInfosResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockInfosRequest, ...grpc.CallOption) (*proto.GetBlockInfosResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockInfosRequest, ...grpc.CallOption) *proto.GetBlockInfosResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.GetBlockInfosResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.GetBlockInfosRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeClient_GetBlockInfos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockInfos'
type NodeClient_GetBlockInfos_Call struct {
        *mock.Call
}

// GetBlockInfos is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.GetBlockInfosRequest
//   - opts ...grpc.CallOption
func (_e *NodeClient_Expecter) GetBlockInfos(ctx interface{}, in interface{}, opts ...interface{}) *NodeClient_GetBlockInfos_Call <span class="cov0" title="0">{
        return &amp;NodeClient_GetBlockInfos_Call{Call: _e.mock.On("GetBlockInfos",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NodeClient_GetBlockInfos_Call) Run(run func(ctx context.Context, in *proto.GetBlockInfosRequest, opts ...grpc.CallOption)) *NodeClient_GetBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.GetBlockInfosRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeClient_GetBlockInfos_Call) Return(_a0 *proto.GetBlockInfosResponse, _a1 error) *NodeClient_GetBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeClient_GetBlockInfos_Call) RunAndReturn(run func(context.Context, *proto.GetBlockInfosRequest, ...grpc.CallOption) (*proto.GetBlockInfosResponse, error)) *NodeClient_GetBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WriteBlock provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) WriteBlock(ctx context.Context, in *proto.WriteBlockRequest, opts ...grpc.CallOption) (*proto.WriteBlockResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WriteBlock")</span>
        }

        <span class="cov0" title="0">var r0 *proto.WriteBlockResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.WriteBlockRequest, ...grpc.CallOption) (*proto.WriteBlockResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.WriteBlockRequest, ...grpc.CallOption) *proto.WriteBlockResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.WriteBlockResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.WriteBlockRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeClient_WriteBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteBlock'
type NodeClient_WriteBlock_Call struct {
        *mock.Call
}

// WriteBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.WriteBlockRequest
//   - opts ...grpc.CallOption
func (_e *NodeClient_Expecter) WriteBlock(ctx interface{}, in interface{}, opts ...interface{}) *NodeClient_WriteBlock_Call <span class="cov0" title="0">{
        return &amp;NodeClient_WriteBlock_Call{Call: _e.mock.On("WriteBlock",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NodeClient_WriteBlock_Call) Run(run func(ctx context.Context, in *proto.WriteBlockRequest, opts ...grpc.CallOption)) *NodeClient_WriteBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.WriteBlockRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeClient_WriteBlock_Call) Return(_a0 *proto.WriteBlockResponse, _a1 error) *NodeClient_WriteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeClient_WriteBlock_Call) RunAndReturn(run func(context.Context, *proto.WriteBlockRequest, ...grpc.CallOption) (*proto.WriteBlockResponse, error)) *NodeClient_WriteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewNodeClient creates a new instance of NodeClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNodeClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *NodeClient <span class="cov0" title="0">{
        mock := &amp;NodeClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        proto "github.com/cirglo.com/dfs/pkg/proto"
        mock "github.com/stretchr/testify/mock"
)

// NodeServer is an autogenerated mock type for the NodeServer type
type NodeServer struct {
        mock.Mock
}

type NodeServer_Expecter struct {
        mock *mock.Mock
}

func (_m *NodeServer) EXPECT() *NodeServer_Expecter <span class="cov0" title="0">{
        return &amp;NodeServer_Expecter{mock: &amp;_m.Mock}
}</span>

// CopyBlock provides a mock function with given fields: _a0, _a1
func (_m *NodeServer) CopyBlock(_a0 context.Context, _a1 *proto.CopyBlockRequest) (*proto.CopyBlockResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CopyBlock")</span>
        }

        <span class="cov0" title="0">var r0 *proto.CopyBlockResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.CopyBlockRequest) (*proto.CopyBlockResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.CopyBlockRequest) *proto.CopyBlockResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.CopyBlockResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.CopyBlockRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeServer_CopyBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyBlock'
type NodeServer_CopyBlock_Call struct {
        *mock.Call
}

// CopyBlock is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.CopyBlockRequest
func (_e *NodeServer_Expecter) CopyBlock(_a0 interface{}, _a1 interface{}) *NodeServer_CopyBlock_Call <span class="cov0" title="0">{
        return &amp;NodeServer_CopyBlock_Call{Call: _e.mock.On("CopyBlock", _a0, _a1)}
}</span>

func (_c *NodeServer_CopyBlock_Call) Run(run func(_a0 context.Context, _a1 *proto.CopyBlockRequest)) *NodeServer_CopyBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.CopyBlockRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeServer_CopyBlock_Call) Return(_a0 *proto.CopyBlockResponse, _a1 error) *NodeServer_CopyBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeServer_CopyBlock_Call) RunAndReturn(run func(context.Context, *proto.CopyBlockRequest) (*proto.CopyBlockResponse, error)) *NodeServer_CopyBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteBlock provides a mock function with given fields: _a0, _a1
func (_m *NodeServer) DeleteBlock(_a0 context.Context, _a1 *proto.DeleteBlockRequest) (*proto.DeleteBlockResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteBlock")</span>
        }

        <span class="cov0" title="0">var r0 *proto.DeleteBlockResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteBlockRequest) (*proto.DeleteBlockResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteBlockRequest) *proto.DeleteBlockResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.DeleteBlockResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.DeleteBlockRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeServer_DeleteBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBlock'
type NodeServer_DeleteBlock_Call struct {
        *mock.Call
}

// DeleteBlock is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.DeleteBlockRequest
func (_e *NodeServer_Expecter) DeleteBlock(_a0 interface{}, _a1 interface{}) *NodeServer_DeleteBlock_Call <span class="cov0" title="0">{
        return &amp;NodeServer_DeleteBlock_Call{Call: _e.mock.On("DeleteBlock", _a0, _a1)}
}</span>

func (_c *NodeServer_DeleteBlock_Call) Run(run func(_a0 context.Context, _a1 *proto.DeleteBlockRequest)) *NodeServer_DeleteBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.DeleteBlockRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeServer_DeleteBlock_Call) Return(_a0 *proto.DeleteBlockResponse, _a1 error) *NodeServer_DeleteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeServer_DeleteBlock_Call) RunAndReturn(run func(context.Context, *proto.DeleteBlockRequest) (*proto.DeleteBlockResponse, error)) *NodeServer_DeleteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBlock provides a mock function with given fields: _a0, _a1
func (_m *NodeServer) GetBlock(_a0 context.Context, _a1 *proto.GetBlockRequest) (*proto.GetBlockResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBlock")</span>
        }

        <span class="cov0" title="0">var r0 *proto.GetBlockResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockRequest) (*proto.GetBlockResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockRequest) *proto.GetBlockResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.GetBlockResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.GetBlockRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeServer_GetBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlock'
type NodeServer_GetBlock_Call struct {
        *mock.Call
}

// GetBlock is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.GetBlockRequest
func (_e *NodeServer_Expecter) GetBlock(_a0 interface{}, _a1 interface{}) *NodeServer_GetBlock_Call <span class="cov0" title="0">{
        return &amp;NodeServer_GetBlock_Call{Call: _e.mock.On("GetBlock", _a0, _a1)}
}</span>

func (_c *NodeServer_GetBlock_Call) Run(run func(_a0 context.Context, _a1 *proto.GetBlockRequest)) *NodeServer_GetBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.GetBlockRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeServer_GetBlock_Call) Return(_a0 *proto.GetBlockResponse, _a1 error) *NodeServer_GetBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeServer_GetBlock_Call) RunAndReturn(run func(context.Context, *proto.GetBlockRequest) (*proto.GetBlockResponse, error)) *NodeServer_GetBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBlockInfo provides a mock function with given fields: _a0, _a1
func (_m *NodeServer) GetBlockInfo(_a0 context.Context, _a1 *proto.GetBlockInfoRequest) (*proto.GetBlockInfoResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBlockInfo")</span>
        }

        <span class="cov0" title="0">var r0 *proto.GetBlockInfoResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockInfoRequest) (*proto.GetBlockInfoResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockInfoRequest) *proto.GetBlockInfoResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.GetBlockInfoResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.GetBlockInfoRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeServer_GetBlockInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockInfo'
type NodeServer_GetBlockInfo_Call struct {
        *mock.Call
}

// GetBlockInfo is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.GetBlockInfoRequest
func (_e *NodeServer_Expecter) GetBlockInfo(_a0 interface{}, _a1 interface{}) *NodeServer_GetBlockInfo_Call <span class="cov0" title="0">{
        return &amp;NodeServer_GetBlockInfo_Call{Call: _e.mock.On("GetBlockInfo", _a0, _a1)}
}</span>

func (_c *NodeServer_GetBlockInfo_Call) Run(run func(_a0 context.Context, _a1 *proto.GetBlockInfoRequest)) *NodeServer_GetBlockInfo_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.GetBlockInfoRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeServer_GetBlockInfo_Call) Return(_a0 *proto.GetBlockInfoResponse, _a1 error) *NodeServer_GetBlockInfo_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeServer_GetBlockInfo_Call) RunAndReturn(run func(context.Context, *proto.GetBlockInfoRequest) (*proto.GetBlockInfoResponse, error)) *NodeServer_GetBlockInfo_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBlockInfos provides a mock function with given fields: _a0, _a1
func (_m *NodeServer) GetBlockInfos(_a0 context.Context, _a1 *proto.GetBlockInfosRequest) (*proto.GetBlockInfosResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBlockInfos")</span>
        }

        <span class="cov0" title="0">var r0 *proto.GetBlockInfosResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockInfosRequest) (*proto.GetBlockInfosResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.GetBlockInfosRequest) *proto.GetBlockInfosResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.GetBlockInfosResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.GetBlockInfosRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeServer_GetBlockInfos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockInfos'
type NodeServer_GetBlockInfos_Call struct {
        *mock.Call
}

// GetBlockInfos is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.GetBlockInfosRequest
func (_e *NodeServer_Expecter) GetBlockInfos(_a0 interface{}, _a1 interface{}) *NodeServer_GetBlockInfos_Call <span class="cov0" title="0">{
        return &amp;NodeServer_GetBlockInfos_Call{Call: _e.mock.On("GetBlockInfos", _a0, _a1)}
}</span>

func (_c *NodeServer_GetBlockInfos_Call) Run(run func(_a0 context.Context, _a1 *proto.GetBlockInfosRequest)) *NodeServer_GetBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.GetBlockInfosRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeServer_GetBlockInfos_Call) Return(_a0 *proto.GetBlockInfosResponse, _a1 error) *NodeServer_GetBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeServer_GetBlockInfos_Call) RunAndReturn(run func(context.Context, *proto.GetBlockInfosRequest) (*proto.GetBlockInfosResponse, error)) *NodeServer_GetBlockInfos_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WriteBlock provides a mock function with given fields: _a0, _a1
func (_m *NodeServer) WriteBlock(_a0 context.Context, _a1 *proto.WriteBlockRequest) (*proto.WriteBlockResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WriteBlock")</span>
        }

        <span class="cov0" title="0">var r0 *proto.WriteBlockResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.WriteBlockRequest) (*proto.WriteBlockResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.WriteBlockRequest) *proto.WriteBlockResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.WriteBlockResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.WriteBlockRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NodeServer_WriteBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteBlock'
type NodeServer_WriteBlock_Call struct {
        *mock.Call
}

// WriteBlock is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.WriteBlockRequest
func (_e *NodeServer_Expecter) WriteBlock(_a0 interface{}, _a1 interface{}) *NodeServer_WriteBlock_Call <span class="cov0" title="0">{
        return &amp;NodeServer_WriteBlock_Call{Call: _e.mock.On("WriteBlock", _a0, _a1)}
}</span>

func (_c *NodeServer_WriteBlock_Call) Run(run func(_a0 context.Context, _a1 *proto.WriteBlockRequest)) *NodeServer_WriteBlock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.WriteBlockRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeServer_WriteBlock_Call) Return(_a0 *proto.WriteBlockResponse, _a1 error) *NodeServer_WriteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NodeServer_WriteBlock_Call) RunAndReturn(run func(context.Context, *proto.WriteBlockRequest) (*proto.WriteBlockResponse, error)) *NodeServer_WriteBlock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// mustEmbedUnimplementedNodeServer provides a mock function with no fields
func (_m *NodeServer) mustEmbedUnimplementedNodeServer() <span class="cov0" title="0">{
        _m.Called()
}</span>

// NodeServer_mustEmbedUnimplementedNodeServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'mustEmbedUnimplementedNodeServer'
type NodeServer_mustEmbedUnimplementedNodeServer_Call struct {
        *mock.Call
}

// mustEmbedUnimplementedNodeServer is a helper method to define mock.On call
func (_e *NodeServer_Expecter) mustEmbedUnimplementedNodeServer() *NodeServer_mustEmbedUnimplementedNodeServer_Call <span class="cov0" title="0">{
        return &amp;NodeServer_mustEmbedUnimplementedNodeServer_Call{Call: _e.mock.On("mustEmbedUnimplementedNodeServer")}
}</span>

func (_c *NodeServer_mustEmbedUnimplementedNodeServer_Call) Run(run func()) *NodeServer_mustEmbedUnimplementedNodeServer_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NodeServer_mustEmbedUnimplementedNodeServer_Call) Return() *NodeServer_mustEmbedUnimplementedNodeServer_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *NodeServer_mustEmbedUnimplementedNodeServer_Call) RunAndReturn(run func()) *NodeServer_mustEmbedUnimplementedNodeServer_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// NewNodeServer creates a new instance of NodeServer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNodeServer(t interface {
        mock.TestingT
        Cleanup(func())
}) *NodeServer <span class="cov0" title="0">{
        mock := &amp;NodeServer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        grpc "google.golang.org/grpc"

        mock "github.com/stretchr/testify/mock"

        proto "github.com/cirglo.com/dfs/pkg/proto"
)

// NotificationClient is an autogenerated mock type for the NotificationClient type
type NotificationClient struct {
        mock.Mock
}

type NotificationClient_Expecter struct {
        mock *mock.Mock
}

func (_m *NotificationClient) EXPECT() *NotificationClient_Expecter <span class="cov0" title="0">{
        return &amp;NotificationClient_Expecter{mock: &amp;_m.Mock}
}</span>

// NotifyBlockAdded provides a mock function with given fields: ctx, in, opts
func (_m *NotificationClient) NotifyBlockAdded(ctx context.Context, in *proto.NotifyBlockAddedRequest, opts ...grpc.CallOption) (*proto.NotifyBlockAddedResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NotifyBlockAdded")</span>
        }

        <span class="cov0" title="0">var r0 *proto.NotifyBlockAddedResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockAddedRequest, ...grpc.CallOption) (*proto.NotifyBlockAddedResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockAddedRequest, ...grpc.CallOption) *proto.NotifyBlockAddedResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.NotifyBlockAddedResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.NotifyBlockAddedRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NotificationClient_NotifyBlockAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyBlockAdded'
type NotificationClient_NotifyBlockAdded_Call struct {
        *mock.Call
}

// NotifyBlockAdded is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.NotifyBlockAddedRequest
//   - opts ...grpc.CallOption
func (_e *NotificationClient_Expecter) NotifyBlockAdded(ctx interface{}, in interface{}, opts ...interface{}) *NotificationClient_NotifyBlockAdded_Call <span class="cov0" title="0">{
        return &amp;NotificationClient_NotifyBlockAdded_Call{Call: _e.mock.On("NotifyBlockAdded",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NotificationClient_NotifyBlockAdded_Call) Run(run func(ctx context.Context, in *proto.NotifyBlockAddedRequest, opts ...grpc.CallOption)) *NotificationClient_NotifyBlockAdded_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.NotifyBlockAddedRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NotificationClient_NotifyBlockAdded_Call) Return(_a0 *proto.NotifyBlockAddedResponse, _a1 error) *NotificationClient_NotifyBlockAdded_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NotificationClient_NotifyBlockAdded_Call) RunAndReturn(run func(context.Context, *proto.NotifyBlockAddedRequest, ...grpc.CallOption) (*proto.NotifyBlockAddedResponse, error)) *NotificationClient_NotifyBlockAdded_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NotifyBlockPresent provides a mock function with given fields: ctx, in, opts
func (_m *NotificationClient) NotifyBlockPresent(ctx context.Context, in *proto.NotifyBlockPresentRequest, opts ...grpc.CallOption) (*proto.NotifyBlockPresentResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NotifyBlockPresent")</span>
        }

        <span class="cov0" title="0">var r0 *proto.NotifyBlockPresentResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockPresentRequest, ...grpc.CallOption) (*proto.NotifyBlockPresentResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockPresentRequest, ...grpc.CallOption) *proto.NotifyBlockPresentResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.NotifyBlockPresentResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.NotifyBlockPresentRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NotificationClient_NotifyBlockPresent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyBlockPresent'
type NotificationClient_NotifyBlockPresent_Call struct {
        *mock.Call
}

// NotifyBlockPresent is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.NotifyBlockPresentRequest
//   - opts ...grpc.CallOption
func (_e *NotificationClient_Expecter) NotifyBlockPresent(ctx interface{}, in interface{}, opts ...interface{}) *NotificationClient_NotifyBlockPresent_Call <span class="cov0" title="0">{
        return &amp;NotificationClient_NotifyBlockPresent_Call{Call: _e.mock.On("NotifyBlockPresent",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NotificationClient_NotifyBlockPresent_Call) Run(run func(ctx context.Context, in *proto.NotifyBlockPresentRequest, opts ...grpc.CallOption)) *NotificationClient_NotifyBlockPresent_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.NotifyBlockPresentRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NotificationClient_NotifyBlockPresent_Call) Return(_a0 *proto.NotifyBlockPresentResponse, _a1 error) *NotificationClient_NotifyBlockPresent_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NotificationClient_NotifyBlockPresent_Call) RunAndReturn(run func(context.Context, *proto.NotifyBlockPresentRequest, ...grpc.CallOption) (*proto.NotifyBlockPresentResponse, error)) *NotificationClient_NotifyBlockPresent_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NotifyBlockRemoved provides a mock function with given fields: ctx, in, opts
func (_m *NotificationClient) NotifyBlockRemoved(ctx context.Context, in *proto.NotifyBlockRemovedRequest, opts ...grpc.CallOption) (*proto.NotifyBlockRemovedResponse, error) <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, in)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NotifyBlockRemoved")</span>
        }

        <span class="cov0" title="0">var r0 *proto.NotifyBlockRemovedResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockRemovedRequest, ...grpc.CallOption) (*proto.NotifyBlockRemovedResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, in, opts...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockRemovedRequest, ...grpc.CallOption) *proto.NotifyBlockRemovedResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.NotifyBlockRemovedResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.NotifyBlockRemovedRequest, ...grpc.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, in, opts...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NotificationClient_NotifyBlockRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyBlockRemoved'
type NotificationClient_NotifyBlockRemoved_Call struct {
        *mock.Call
}

// NotifyBlockRemoved is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.NotifyBlockRemovedRequest
//   - opts ...grpc.CallOption
func (_e *NotificationClient_Expecter) NotifyBlockRemoved(ctx interface{}, in interface{}, opts ...interface{}) *NotificationClient_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        return &amp;NotificationClient_NotifyBlockRemoved_Call{Call: _e.mock.On("NotifyBlockRemoved",
                append([]interface{}{ctx, in}, opts...)...)}
}</span>

func (_c *NotificationClient_NotifyBlockRemoved_Call) Run(run func(ctx context.Context, in *proto.NotifyBlockRemovedRequest, opts ...grpc.CallOption)) *NotificationClient_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]grpc.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(grpc.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(*proto.NotifyBlockRemovedRequest), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *NotificationClient_NotifyBlockRemoved_Call) Return(_a0 *proto.NotifyBlockRemovedResponse, _a1 error) *NotificationClient_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NotificationClient_NotifyBlockRemoved_Call) RunAndReturn(run func(context.Context, *proto.NotifyBlockRemovedRequest, ...grpc.CallOption) (*proto.NotifyBlockRemovedResponse, error)) *NotificationClient_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewNotificationClient creates a new instance of NotificationClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNotificationClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *NotificationClient <span class="cov0" title="0">{
        mock := &amp;NotificationClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        proto "github.com/cirglo.com/dfs/pkg/proto"
        mock "github.com/stretchr/testify/mock"
)

// NotificationServer is an autogenerated mock type for the NotificationServer type
type NotificationServer struct {
        mock.Mock
}

type NotificationServer_Expecter struct {
        mock *mock.Mock
}

func (_m *NotificationServer) EXPECT() *NotificationServer_Expecter <span class="cov0" title="0">{
        return &amp;NotificationServer_Expecter{mock: &amp;_m.Mock}
}</span>

// NotifyBlockAdded provides a mock function with given fields: _a0, _a1
func (_m *NotificationServer) NotifyBlockAdded(_a0 context.Context, _a1 *proto.NotifyBlockAddedRequest) (*proto.NotifyBlockAddedResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NotifyBlockAdded")</span>
        }

        <span class="cov0" title="0">var r0 *proto.NotifyBlockAddedResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockAddedRequest) (*proto.NotifyBlockAddedResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockAddedRequest) *proto.NotifyBlockAddedResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.NotifyBlockAddedResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.NotifyBlockAddedRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NotificationServer_NotifyBlockAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyBlockAdded'
type NotificationServer_NotifyBlockAdded_Call struct {
        *mock.Call
}

// NotifyBlockAdded is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.NotifyBlockAddedRequest
func (_e *NotificationServer_Expecter) NotifyBlockAdded(_a0 interface{}, _a1 interface{}) *NotificationServer_NotifyBlockAdded_Call <span class="cov0" title="0">{
        return &amp;NotificationServer_NotifyBlockAdded_Call{Call: _e.mock.On("NotifyBlockAdded", _a0, _a1)}
}</span>

func (_c *NotificationServer_NotifyBlockAdded_Call) Run(run func(_a0 context.Context, _a1 *proto.NotifyBlockAddedRequest)) *NotificationServer_NotifyBlockAdded_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.NotifyBlockAddedRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NotificationServer_NotifyBlockAdded_Call) Return(_a0 *proto.NotifyBlockAddedResponse, _a1 error) *NotificationServer_NotifyBlockAdded_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NotificationServer_NotifyBlockAdded_Call) RunAndReturn(run func(context.Context, *proto.NotifyBlockAddedRequest) (*proto.NotifyBlockAddedResponse, error)) *NotificationServer_NotifyBlockAdded_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NotifyBlockPresent provides a mock function with given fields: _a0, _a1
func (_m *NotificationServer) NotifyBlockPresent(_a0 context.Context, _a1 *proto.NotifyBlockPresentRequest) (*proto.NotifyBlockPresentResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NotifyBlockPresent")</span>
        }

        <span class="cov0" title="0">var r0 *proto.NotifyBlockPresentResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockPresentRequest) (*proto.NotifyBlockPresentResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockPresentRequest) *proto.NotifyBlockPresentResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.NotifyBlockPresentResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.NotifyBlockPresentRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NotificationServer_NotifyBlockPresent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyBlockPresent'
type NotificationServer_NotifyBlockPresent_Call struct {
        *mock.Call
}

// NotifyBlockPresent is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.NotifyBlockPresentRequest
func (_e *NotificationServer_Expecter) NotifyBlockPresent(_a0 interface{}, _a1 interface{}) *NotificationServer_NotifyBlockPresent_Call <span class="cov0" title="0">{
        return &amp;NotificationServer_NotifyBlockPresent_Call{Call: _e.mock.On("NotifyBlockPresent", _a0, _a1)}
}</span>

func (_c *NotificationServer_NotifyBlockPresent_Call) Run(run func(_a0 context.Context, _a1 *proto.NotifyBlockPresentRequest)) *NotificationServer_NotifyBlockPresent_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.NotifyBlockPresentRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NotificationServer_NotifyBlockPresent_Call) Return(_a0 *proto.NotifyBlockPresentResponse, _a1 error) *NotificationServer_NotifyBlockPresent_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NotificationServer_NotifyBlockPresent_Call) RunAndReturn(run func(context.Context, *proto.NotifyBlockPresentRequest) (*proto.NotifyBlockPresentResponse, error)) *NotificationServer_NotifyBlockPresent_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NotifyBlockRemoved provides a mock function with given fields: _a0, _a1
func (_m *NotificationServer) NotifyBlockRemoved(_a0 context.Context, _a1 *proto.NotifyBlockRemovedRequest) (*proto.NotifyBlockRemovedResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for NotifyBlockRemoved")</span>
        }

        <span class="cov0" title="0">var r0 *proto.NotifyBlockRemovedResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockRemovedRequest) (*proto.NotifyBlockRemovedResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0, _a1)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *proto.NotifyBlockRemovedRequest) *proto.NotifyBlockRemovedResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*proto.NotifyBlockRemovedResponse)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *proto.NotifyBlockRemovedRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NotificationServer_NotifyBlockRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyBlockRemoved'
type NotificationServer_NotifyBlockRemoved_Call struct {
        *mock.Call
}

// NotifyBlockRemoved is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *proto.NotifyBlockRemovedRequest
func (_e *NotificationServer_Expecter) NotifyBlockRemoved(_a0 interface{}, _a1 interface{}) *NotificationServer_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        return &amp;NotificationServer_NotifyBlockRemoved_Call{Call: _e.mock.On("NotifyBlockRemoved", _a0, _a1)}
}</span>

func (_c *NotificationServer_NotifyBlockRemoved_Call) Run(run func(_a0 context.Context, _a1 *proto.NotifyBlockRemovedRequest)) *NotificationServer_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*proto.NotifyBlockRemovedRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NotificationServer_NotifyBlockRemoved_Call) Return(_a0 *proto.NotifyBlockRemovedResponse, _a1 error) *NotificationServer_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *NotificationServer_NotifyBlockRemoved_Call) RunAndReturn(run func(context.Context, *proto.NotifyBlockRemovedRequest) (*proto.NotifyBlockRemovedResponse, error)) *NotificationServer_NotifyBlockRemoved_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// mustEmbedUnimplementedNotificationServer provides a mock function with no fields
func (_m *NotificationServer) mustEmbedUnimplementedNotificationServer() <span class="cov0" title="0">{
        _m.Called()
}</span>

// NotificationServer_mustEmbedUnimplementedNotificationServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'mustEmbedUnimplementedNotificationServer'
type NotificationServer_mustEmbedUnimplementedNotificationServer_Call struct {
        *mock.Call
}

// mustEmbedUnimplementedNotificationServer is a helper method to define mock.On call
func (_e *NotificationServer_Expecter) mustEmbedUnimplementedNotificationServer() *NotificationServer_mustEmbedUnimplementedNotificationServer_Call <span class="cov0" title="0">{
        return &amp;NotificationServer_mustEmbedUnimplementedNotificationServer_Call{Call: _e.mock.On("mustEmbedUnimplementedNotificationServer")}
}</span>

func (_c *NotificationServer_mustEmbedUnimplementedNotificationServer_Call) Run(run func()) *NotificationServer_mustEmbedUnimplementedNotificationServer_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *NotificationServer_mustEmbedUnimplementedNotificationServer_Call) Return() *NotificationServer_mustEmbedUnimplementedNotificationServer_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *NotificationServer_mustEmbedUnimplementedNotificationServer_Call) RunAndReturn(run func()) *NotificationServer_mustEmbedUnimplementedNotificationServer_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// NewNotificationServer creates a new instance of NotificationServer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNotificationServer(t interface {
        mock.TestingT
        Cleanup(func())
}) *NotificationServer <span class="cov0" title="0">{
        mock := &amp;NotificationServer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        name "github.com/cirglo.com/dfs/pkg/name"
        mock "github.com/stretchr/testify/mock"
)

// Principal is an autogenerated mock type for the Principal type
type Principal struct {
        mock.Mock
}

type Principal_Expecter struct {
        mock *mock.Mock
}

func (_m *Principal) EXPECT() *Principal_Expecter <span class="cov0" title="0">{
        return &amp;Principal_Expecter{mock: &amp;_m.Mock}
}</span>

// ComputePrivileges provides a mock function with given fields: hasPermissionsList
func (_m *Principal) ComputePrivileges(hasPermissionsList ...name.HasPermissions) name.Privileges <span class="cov0" title="0">{
        _va := make([]interface{}, len(hasPermissionsList))
        for _i := range hasPermissionsList </span><span class="cov0" title="0">{
                _va[_i] = hasPermissionsList[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ComputePrivileges")</span>
        }

        <span class="cov0" title="0">var r0 name.Privileges
        if rf, ok := ret.Get(0).(func(...name.HasPermissions) name.Privileges); ok </span><span class="cov0" title="0">{
                r0 = rf(hasPermissionsList...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(name.Privileges)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Principal_ComputePrivileges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputePrivileges'
type Principal_ComputePrivileges_Call struct {
        *mock.Call
}

// ComputePrivileges is a helper method to define mock.On call
//   - hasPermissionsList ...name.HasPermissions
func (_e *Principal_Expecter) ComputePrivileges(hasPermissionsList ...interface{}) *Principal_ComputePrivileges_Call <span class="cov0" title="0">{
        return &amp;Principal_ComputePrivileges_Call{Call: _e.mock.On("ComputePrivileges",
                append([]interface{}{}, hasPermissionsList...)...)}
}</span>

func (_c *Principal_ComputePrivileges_Call) Run(run func(hasPermissionsList ...name.HasPermissions)) *Principal_ComputePrivileges_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]name.HasPermissions, len(args)-0)
                for i, a := range args[0:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(name.HasPermissions)
                        }</span>
                }
                <span class="cov0" title="0">run(variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *Principal_ComputePrivileges_Call) Return(_a0 name.Privileges) *Principal_ComputePrivileges_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Principal_ComputePrivileges_Call) RunAndReturn(run func(...name.HasPermissions) name.Privileges) *Principal_ComputePrivileges_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewPrincipal creates a new instance of Principal. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPrincipal(t interface {
        mock.TestingT
        Cleanup(func())
}) *Principal <span class="cov0" title="0">{
        mock := &amp;Principal{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        name "github.com/cirglo.com/dfs/pkg/name"
        mock "github.com/stretchr/testify/mock"
)

// SecurityService is an autogenerated mock type for the SecurityService type
type SecurityService struct {
        mock.Mock
}

type SecurityService_Expecter struct {
        mock *mock.Mock
}

func (_m *SecurityService) EXPECT() *SecurityService_Expecter <span class="cov0" title="0">{
        return &amp;SecurityService_Expecter{mock: &amp;_m.Mock}
}</span>

// AddUserToGroup provides a mock function with given fields: userName, groupName
func (_m *SecurityService) AddUserToGroup(userName string, groupName string) error <span class="cov0" title="0">{
        ret := _m.Called(userName, groupName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddUserToGroup")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(userName, groupName)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// SecurityService_AddUserToGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddUserToGroup'
type SecurityService_AddUserToGroup_Call struct {
        *mock.Call
}

// AddUserToGroup is a helper method to define mock.On call
//   - userName string
//   - groupName string
func (_e *SecurityService_Expecter) AddUserToGroup(userName interface{}, groupName interface{}) *SecurityService_AddUserToGroup_Call <span class="cov0" title="0">{
        return &amp;SecurityService_AddUserToGroup_Call{Call: _e.mock.On("AddUserToGroup", userName, groupName)}
}</span>

func (_c *SecurityService_AddUserToGroup_Call) Run(run func(userName string, groupName string)) *SecurityService_AddUserToGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_AddUserToGroup_Call) Return(_a0 error) *SecurityService_AddUserToGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *SecurityService_AddUserToGroup_Call) RunAndReturn(run func(string, string) error) *SecurityService_AddUserToGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// AuthenticateUser provides a mock function with given fields: userName, password
func (_m *SecurityService) AuthenticateUser(userName string, password string) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(userName, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AuthenticateUser")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(string, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(userName, password)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(userName, password)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(userName, password)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// SecurityService_AuthenticateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthenticateUser'
type SecurityService_AuthenticateUser_Call struct {
        *mock.Call
}

// AuthenticateUser is a helper method to define mock.On call
//   - userName string
//   - password string
func (_e *SecurityService_Expecter) AuthenticateUser(userName interface{}, password interface{}) *SecurityService_AuthenticateUser_Call <span class="cov0" title="0">{
        return &amp;SecurityService_AuthenticateUser_Call{Call: _e.mock.On("AuthenticateUser", userName, password)}
}</span>

func (_c *SecurityService_AuthenticateUser_Call) Run(run func(userName string, password string)) *SecurityService_AuthenticateUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_AuthenticateUser_Call) Return(_a0 string, _a1 error) *SecurityService_AuthenticateUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *SecurityService_AuthenticateUser_Call) RunAndReturn(run func(string, string) (string, error)) *SecurityService_AuthenticateUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ChangeUserPassword provides a mock function with given fields: userName, newPassword
func (_m *SecurityService) ChangeUserPassword(userName string, newPassword string) error <span class="cov0" title="0">{
        ret := _m.Called(userName, newPassword)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ChangeUserPassword")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(userName, newPassword)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// SecurityService_ChangeUserPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeUserPassword'
type SecurityService_ChangeUserPassword_Call struct {
        *mock.Call
}

// ChangeUserPassword is a helper method to define mock.On call
//   - userName string
//   - newPassword string
func (_e *SecurityService_Expecter) ChangeUserPassword(userName interface{}, newPassword interface{}) *SecurityService_ChangeUserPassword_Call <span class="cov0" title="0">{
        return &amp;SecurityService_ChangeUserPassword_Call{Call: _e.mock.On("ChangeUserPassword", userName, newPassword)}
}</span>

func (_c *SecurityService_ChangeUserPassword_Call) Run(run func(userName string, newPassword string)) *SecurityService_ChangeUserPassword_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_ChangeUserPassword_Call) Return(_a0 error) *SecurityService_ChangeUserPassword_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *SecurityService_ChangeUserPassword_Call) RunAndReturn(run func(string, string) error) *SecurityService_ChangeUserPassword_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateGroup provides a mock function with given fields: group
func (_m *SecurityService) CreateGroup(group name.Group) error <span class="cov0" title="0">{
        ret := _m.Called(group)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateGroup")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(name.Group) error); ok </span><span class="cov0" title="0">{
                r0 = rf(group)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// SecurityService_CreateGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateGroup'
type SecurityService_CreateGroup_Call struct {
        *mock.Call
}

// CreateGroup is a helper method to define mock.On call
//   - group name.Group
func (_e *SecurityService_Expecter) CreateGroup(group interface{}) *SecurityService_CreateGroup_Call <span class="cov0" title="0">{
        return &amp;SecurityService_CreateGroup_Call{Call: _e.mock.On("CreateGroup", group)}
}</span>

func (_c *SecurityService_CreateGroup_Call) Run(run func(group name.Group)) *SecurityService_CreateGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(name.Group))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_CreateGroup_Call) Return(_a0 error) *SecurityService_CreateGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *SecurityService_CreateGroup_Call) RunAndReturn(run func(name.Group) error) *SecurityService_CreateGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateUser provides a mock function with given fields: user
func (_m *SecurityService) CreateUser(user name.User) error <span class="cov0" title="0">{
        ret := _m.Called(user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateUser")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(name.User) error); ok </span><span class="cov0" title="0">{
                r0 = rf(user)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// SecurityService_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type SecurityService_CreateUser_Call struct {
        *mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - user name.User
func (_e *SecurityService_Expecter) CreateUser(user interface{}) *SecurityService_CreateUser_Call <span class="cov0" title="0">{
        return &amp;SecurityService_CreateUser_Call{Call: _e.mock.On("CreateUser", user)}
}</span>

func (_c *SecurityService_CreateUser_Call) Run(run func(user name.User)) *SecurityService_CreateUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(name.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_CreateUser_Call) Return(_a0 error) *SecurityService_CreateUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *SecurityService_CreateUser_Call) RunAndReturn(run func(name.User) error) *SecurityService_CreateUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteGroup provides a mock function with given fields: groupName
func (_m *SecurityService) DeleteGroup(groupName string) error <span class="cov0" title="0">{
        ret := _m.Called(groupName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteGroup")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(groupName)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// SecurityService_DeleteGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroup'
type SecurityService_DeleteGroup_Call struct {
        *mock.Call
}

// DeleteGroup is a helper method to define mock.On call
//   - groupName string
func (_e *SecurityService_Expecter) DeleteGroup(groupName interface{}) *SecurityService_DeleteGroup_Call <span class="cov0" title="0">{
        return &amp;SecurityService_DeleteGroup_Call{Call: _e.mock.On("DeleteGroup", groupName)}
}</span>

func (_c *SecurityService_DeleteGroup_Call) Run(run func(groupName string)) *SecurityService_DeleteGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_DeleteGroup_Call) Return(_a0 error) *SecurityService_DeleteGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *SecurityService_DeleteGroup_Call) RunAndReturn(run func(string) error) *SecurityService_DeleteGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteUser provides a mock function with given fields: userName
func (_m *SecurityService) DeleteUser(userName string) error <span class="cov0" title="0">{
        ret := _m.Called(userName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteUser")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(userName)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// SecurityService_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type SecurityService_DeleteUser_Call struct {
        *mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - userName string
func (_e *SecurityService_Expecter) DeleteUser(userName interface{}) *SecurityService_DeleteUser_Call <span class="cov0" title="0">{
        return &amp;SecurityService_DeleteUser_Call{Call: _e.mock.On("DeleteUser", userName)}
}</span>

func (_c *SecurityService_DeleteUser_Call) Run(run func(userName string)) *SecurityService_DeleteUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_DeleteUser_Call) Return(_a0 error) *SecurityService_DeleteUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *SecurityService_DeleteUser_Call) RunAndReturn(run func(string) error) *SecurityService_DeleteUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetAllGroups provides a mock function with no fields
func (_m *SecurityService) GetAllGroups() ([]name.Group, error) <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAllGroups")</span>
        }

        <span class="cov0" title="0">var r0 []name.Group
        var r1 error
        if rf, ok := ret.Get(0).(func() ([]name.Group, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func() []name.Group); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]name.Group)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// SecurityService_GetAllGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllGroups'
type SecurityService_GetAllGroups_Call struct {
        *mock.Call
}

// GetAllGroups is a helper method to define mock.On call
func (_e *SecurityService_Expecter) GetAllGroups() *SecurityService_GetAllGroups_Call <span class="cov0" title="0">{
        return &amp;SecurityService_GetAllGroups_Call{Call: _e.mock.On("GetAllGroups")}
}</span>

func (_c *SecurityService_GetAllGroups_Call) Run(run func()) *SecurityService_GetAllGroups_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_GetAllGroups_Call) Return(_a0 []name.Group, _a1 error) *SecurityService_GetAllGroups_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *SecurityService_GetAllGroups_Call) RunAndReturn(run func() ([]name.Group, error)) *SecurityService_GetAllGroups_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetAllUsers provides a mock function with no fields
func (_m *SecurityService) GetAllUsers() ([]name.User, error) <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAllUsers")</span>
        }

        <span class="cov0" title="0">var r0 []name.User
        var r1 error
        if rf, ok := ret.Get(0).(func() ([]name.User, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func() []name.User); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]name.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// SecurityService_GetAllUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllUsers'
type SecurityService_GetAllUsers_Call struct {
        *mock.Call
}

// GetAllUsers is a helper method to define mock.On call
func (_e *SecurityService_Expecter) GetAllUsers() *SecurityService_GetAllUsers_Call <span class="cov0" title="0">{
        return &amp;SecurityService_GetAllUsers_Call{Call: _e.mock.On("GetAllUsers")}
}</span>

func (_c *SecurityService_GetAllUsers_Call) Run(run func()) *SecurityService_GetAllUsers_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_GetAllUsers_Call) Return(_a0 []name.User, _a1 error) *SecurityService_GetAllUsers_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *SecurityService_GetAllUsers_Call) RunAndReturn(run func() ([]name.User, error)) *SecurityService_GetAllUsers_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetGroup provides a mock function with given fields: groupName
func (_m *SecurityService) GetGroup(groupName string) (name.Group, error) <span class="cov0" title="0">{
        ret := _m.Called(groupName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetGroup")</span>
        }

        <span class="cov0" title="0">var r0 name.Group
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (name.Group, error)); ok </span><span class="cov0" title="0">{
                return rf(groupName)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) name.Group); ok </span><span class="cov0" title="0">{
                r0 = rf(groupName)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(name.Group)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(groupName)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// SecurityService_GetGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroup'
type SecurityService_GetGroup_Call struct {
        *mock.Call
}

// GetGroup is a helper method to define mock.On call
//   - groupName string
func (_e *SecurityService_Expecter) GetGroup(groupName interface{}) *SecurityService_GetGroup_Call <span class="cov0" title="0">{
        return &amp;SecurityService_GetGroup_Call{Call: _e.mock.On("GetGroup", groupName)}
}</span>

func (_c *SecurityService_GetGroup_Call) Run(run func(groupName string)) *SecurityService_GetGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_GetGroup_Call) Return(_a0 name.Group, _a1 error) *SecurityService_GetGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *SecurityService_GetGroup_Call) RunAndReturn(run func(string) (name.Group, error)) *SecurityService_GetGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUser provides a mock function with given fields: userName
func (_m *SecurityService) GetUser(userName string) (name.User, error) <span class="cov0" title="0">{
        ret := _m.Called(userName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUser")</span>
        }

        <span class="cov0" title="0">var r0 name.User
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (name.User, error)); ok </span><span class="cov0" title="0">{
                return rf(userName)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) name.User); ok </span><span class="cov0" title="0">{
                r0 = rf(userName)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(name.User)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(userName)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// SecurityService_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type SecurityService_GetUser_Call struct {
        *mock.Call
}

// GetUser is a helper method to define mock.On call
//   - userName string
func (_e *SecurityService_Expecter) GetUser(userName interface{}) *SecurityService_GetUser_Call <span class="cov0" title="0">{
        return &amp;SecurityService_GetUser_Call{Call: _e.mock.On("GetUser", userName)}
}</span>

func (_c *SecurityService_GetUser_Call) Run(run func(userName string)) *SecurityService_GetUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_GetUser_Call) Return(_a0 name.User, _a1 error) *SecurityService_GetUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *SecurityService_GetUser_Call) RunAndReturn(run func(string) (name.User, error)) *SecurityService_GetUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Logout provides a mock function with given fields: token
func (_m *SecurityService) Logout(token string) error <span class="cov0" title="0">{
        ret := _m.Called(token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Logout")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// SecurityService_Logout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logout'
type SecurityService_Logout_Call struct {
        *mock.Call
}

// Logout is a helper method to define mock.On call
//   - token string
func (_e *SecurityService_Expecter) Logout(token interface{}) *SecurityService_Logout_Call <span class="cov0" title="0">{
        return &amp;SecurityService_Logout_Call{Call: _e.mock.On("Logout", token)}
}</span>

func (_c *SecurityService_Logout_Call) Run(run func(token string)) *SecurityService_Logout_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_Logout_Call) Return(_a0 error) *SecurityService_Logout_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *SecurityService_Logout_Call) RunAndReturn(run func(string) error) *SecurityService_Logout_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// LookupUserByToken provides a mock function with given fields: token
func (_m *SecurityService) LookupUserByToken(token string) (name.User, error) <span class="cov0" title="0">{
        ret := _m.Called(token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for LookupUserByToken")</span>
        }

        <span class="cov0" title="0">var r0 name.User
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (name.User, error)); ok </span><span class="cov0" title="0">{
                return rf(token)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) name.User); ok </span><span class="cov0" title="0">{
                r0 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(name.User)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// SecurityService_LookupUserByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LookupUserByToken'
type SecurityService_LookupUserByToken_Call struct {
        *mock.Call
}

// LookupUserByToken is a helper method to define mock.On call
//   - token string
func (_e *SecurityService_Expecter) LookupUserByToken(token interface{}) *SecurityService_LookupUserByToken_Call <span class="cov0" title="0">{
        return &amp;SecurityService_LookupUserByToken_Call{Call: _e.mock.On("LookupUserByToken", token)}
}</span>

func (_c *SecurityService_LookupUserByToken_Call) Run(run func(token string)) *SecurityService_LookupUserByToken_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_LookupUserByToken_Call) Return(_a0 name.User, _a1 error) *SecurityService_LookupUserByToken_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *SecurityService_LookupUserByToken_Call) RunAndReturn(run func(string) (name.User, error)) *SecurityService_LookupUserByToken_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// RemoveUserFromGroup provides a mock function with given fields: userName, groupName
func (_m *SecurityService) RemoveUserFromGroup(userName string, groupName string) error <span class="cov0" title="0">{
        ret := _m.Called(userName, groupName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RemoveUserFromGroup")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(userName, groupName)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// SecurityService_RemoveUserFromGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveUserFromGroup'
type SecurityService_RemoveUserFromGroup_Call struct {
        *mock.Call
}

// RemoveUserFromGroup is a helper method to define mock.On call
//   - userName string
//   - groupName string
func (_e *SecurityService_Expecter) RemoveUserFromGroup(userName interface{}, groupName interface{}) *SecurityService_RemoveUserFromGroup_Call <span class="cov0" title="0">{
        return &amp;SecurityService_RemoveUserFromGroup_Call{Call: _e.mock.On("RemoveUserFromGroup", userName, groupName)}
}</span>

func (_c *SecurityService_RemoveUserFromGroup_Call) Run(run func(userName string, groupName string)) *SecurityService_RemoveUserFromGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *SecurityService_RemoveUserFromGroup_Call) Return(_a0 error) *SecurityService_RemoveUserFromGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *SecurityService_RemoveUserFromGroup_Call) RunAndReturn(run func(string, string) error) *SecurityService_RemoveUserFromGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewSecurityService creates a new instance of SecurityService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSecurityService(t interface {
        mock.TestingT
        Cleanup(func())
}) *SecurityService <span class="cov0" title="0">{
        mock := &amp;SecurityService{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package name

import (
        "database/sql"
        "fmt"
        "github.com/cirglo.com/dfs/pkg/proto"
        "github.com/sirupsen/logrus"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "sort"
        "strings"
        "time"
)

type BlockReport struct {
        ID       string
        Path     string
        Hosts    []string
        Sequence uint64
        Length   uint32
        CRC      uint32
}

type FileService interface {
        Stat(p Principal, path string) (FileInfo, error)
        List(p Principal, path string) ([]FileInfo, error)
        CreateFile(p Principal, path string, perms Permissions) (FileInfo, error)
        CreateDir(p Principal, path string, perms Permissions) (FileInfo, error)
        DeleteFile(p Principal, path string) error
        DeleteDir(p Principal, path string) error
        GetBlockInfos(p Principal, path string) ([]BlockInfo, error)
        NotifyBlockPresent(n *proto.NotifyBlockPresentRequest) error
        NotifyBlockAdded(n *proto.NotifyBlockAddedRequest) error
        NotifyBlockRemoved(n *proto.NotifyBlockRemovedRequest) error
        NodeRemoved(host string) error
        GetAllBlockInfos() ([]BlockInfo, error)
}

type FileInfo struct {
        ID          uint64      `gorm:"autoIncrement;primaryKey"`
        CreatedAt   time.Time   `gorm:"autoCreateTime"`
        UpdatedAt   time.Time   `gorm:"autoUpdateTime"`
        ParentID    *uint64     `gorm:"uniqueIndex:idx_fileinfo_name;foreignKey:id"`
        Name        string      `gorm:"size:256;uniqueIndex:idx_fileinfo_name;not null"`
        IsDir       bool        `gorm:"not null"`
        Children    []FileInfo  `gorm:"foreignKey:ParentID"`
        Permissions Permissions `gorm:"embedded;embeddedPrefix:permissions_"`
        BlockInfos  []BlockInfo `gorm:"constraint:OnDelete:CASCADE"`
}

var _ HasPermissions = &amp;FileInfo{}

func (fi *FileInfo) GetSize() uint64 <span class="cov0" title="0">{
        size := uint64(0)

        for _, blockInfo := range fi.BlockInfos </span><span class="cov0" title="0">{
                size += uint64(blockInfo.Length)
        }</span>

        <span class="cov0" title="0">return size</span>
}

func (fi *FileInfo) IsHealthy() bool <span class="cov0" title="0">{
        blockInfos := fi.BlockInfos

        sort.Slice(blockInfos, func(i, j int) bool </span><span class="cov0" title="0">{
                return blockInfos[i].Sequence &lt; blockInfos[j].Sequence
        }</span>)

        <span class="cov0" title="0">for i, blockInfo := range blockInfos </span><span class="cov0" title="0">{
                if blockInfo.Sequence != uint64(i) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if len(blockInfo.Locations) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>

}

func (fi *FileInfo) BeforeSave(_ *gorm.DB) error <span class="cov8" title="1">{
        fi.Name = strings.TrimSpace(fi.Name)

        if strings.Contains(fi.Name, "/") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid name, cannot contain '/': '%s'", fi.Name)
        }</span>

        <span class="cov8" title="1">if fi.IsDir </span><span class="cov8" title="1">{
                if fi.ParentID == nil </span><span class="cov8" title="1">{
                        if len(fi.Name) &gt; 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("root directory cannot have a name but was '%s'", fi.Name)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if len(fi.Name) == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("directory must have a name")
                        }</span>
                }

                <span class="cov8" title="1">if len(fi.BlockInfos) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("directory cannot have blocks")
                }</span>
        } else<span class="cov8" title="1"> {
                if len(fi.Name) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("file must have a name")
                }</span>

                <span class="cov8" title="1">if fi.ParentID == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("file must have a parent")
                }</span>

                <span class="cov8" title="1">if len(fi.Children) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("file cannot have children")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (fi *FileInfo) AfterFind(tx *gorm.DB) error <span class="cov8" title="1">{
        blockInfos := fi.BlockInfos

        sort.Slice(blockInfos, func(i, j int) bool </span><span class="cov0" title="0">{
                return blockInfos[i].Sequence &lt; blockInfos[j].Sequence
        }</span>)

        <span class="cov8" title="1">return nil</span>
}

func (fi *FileInfo) FindChild(name string) (FileInfo, bool) <span class="cov8" title="1">{
        for _, child := range fi.Children </span><span class="cov8" title="1">{
                if child.Name == name </span><span class="cov8" title="1">{
                        return child, true
                }</span>
        }

        <span class="cov0" title="0">return FileInfo{}, false</span>
}

func (fi *FileInfo) GetPermissions() Permissions <span class="cov0" title="0">{
        return fi.Permissions
}</span>

type BlockInfo struct {
        ID         string     `gorm:"primaryKey;not null"`
        CreatedAt  time.Time  `gorm:"autoCreateTime"`
        UpdatedAt  time.Time  `gorm:"autoUpdateTime"`
        Locations  []Location `gorm:"constraint:OnDelete:CASCADE"`
        FileInfoID uint64     `gorm:"uniqueIndex:idx_blockinfo_sequence;not null"`
        Sequence   uint64     `gorm:"uniqueIndex:idx_blockinfo_sequence;not null"`
        Length     uint32     `gorm:"not null"`
        CRC        uint32     `gorm:"not null"`
}

func (bi *BlockInfo) BeforeSave(_ *gorm.DB) error <span class="cov0" title="0">{
        bi.ID = strings.TrimSpace(bi.ID)

        if len(bi.ID) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ID cannot be empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (bi *BlockInfo) AfterFind(tx *gorm.DB) error <span class="cov0" title="0">{
        locations := bi.Locations

        sort.Slice(locations, func(i, j int) bool </span><span class="cov0" title="0">{
                return locations[i].Host &lt; locations[j].Host
        }</span>)

        <span class="cov0" title="0">return nil</span>
}

func (bi *BlockInfo) ContainsHost(host string) bool <span class="cov0" title="0">{
        for _, location := range bi.Locations </span><span class="cov0" title="0">{
                if location.Host == host </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

type Location struct {
        BlockInfoID string `gorm:"uniqueIndex:idx_location;not null"`
        Host        string `gorm:"uniqueIndex:idx_location;not null"`
}

func (l *Location) BeforeSave(_ *gorm.DB) error <span class="cov0" title="0">{
        l.Host = strings.TrimSpace(l.Host)
        if len(l.Host) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("location host is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type FileServiceOpts struct {
        Logger *logrus.Logger
        DB     *gorm.DB
}

func (f FileServiceOpts) Validate() error <span class="cov8" title="1">{
        if f.Logger == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("logger is required")
        }</span>
        <span class="cov8" title="1">if f.DB == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type fileService struct {
        Opts FileServiceOpts
}

var _ FileService = &amp;fileService{}

func NewFileService(opts FileServiceOpts) (FileService, error) <span class="cov8" title="1">{
        if err := opts.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file service options: %w", err)
        }</span>

        <span class="cov8" title="1">fileService := fileService{
                Opts: opts,
        }

        //create root directory if it doesn't exist
        err := opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                rootDir, err := fileService.lookupRoot(tx)
                if err != nil </span><span class="cov8" title="1">{
                        opts.Logger.WithError(err).Info("Could not find root directory. Creating...")
                        rootDir.IsDir = true
                        rootDir.ParentID = nil
                        rootDir.Permissions = Permissions{
                                Owner: "root",
                                Group: "root",
                                OwnerPermission: Permission{
                                        Read:   true,
                                        Write:  true,
                                        Delete: true,
                                },
                                GroupPermission: Permission{
                                        Read:   true,
                                        Write:  true,
                                        Delete: true,
                                },
                                OtherPermission: Permission{
                                        Read:   true,
                                        Write:  true,
                                        Delete: true,
                                },
                        }

                        err = tx.Create(&amp;rootDir).Error
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not create root diretory: %w", err)
                        }</span>

                        <span class="cov8" title="1">opts.Logger.WithField("file-info", rootDir).Info("Created root directory")</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not initialize file system: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;fileService, nil</span>
}

func (f *fileService) cleanPath(path string) (string, string, string, error) <span class="cov8" title="1">{
        trimmedPath := strings.TrimSpace(path)
        trimmedPath = strings.TrimSuffix(trimmedPath, "/")

        if len(trimmedPath) == 0 </span><span class="cov0" title="0">{
                return "", "", "", fmt.Errorf("path cannot be empty")
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(trimmedPath, "/") </span><span class="cov0" title="0">{
                return "", "", "", fmt.Errorf("path must start with / but was '%s'", trimmedPath)
        }</span>

        <span class="cov8" title="1">if trimmedPath == "/" </span><span class="cov0" title="0">{
                return "/", "/", "", nil
        }</span>

        <span class="cov8" title="1">if strings.Count(trimmedPath, "/") == 1 </span><span class="cov8" title="1">{
                name := strings.TrimPrefix(trimmedPath, "/")
                return trimmedPath, "/", name, nil
        }</span>

        <span class="cov0" title="0">lastIndex := strings.LastIndex(trimmedPath, "/")
        if lastIndex == -1 </span><span class="cov0" title="0">{
                return "", "", "", fmt.Errorf("invalid path '%s", trimmedPath)
        }</span>

        <span class="cov0" title="0">parentPath := trimmedPath[0:lastIndex]
        name := trimmedPath[lastIndex+1:]

        return trimmedPath, parentPath, name, nil</span>
}

func (f *fileService) lookupRoot(tx *gorm.DB) (FileInfo, error) <span class="cov8" title="1">{
        fileInfo := FileInfo{}
        err := tx.Where(&amp;FileInfo{ParentID: nil}, "ParentID").Preload(clause.Associations).First(&amp;fileInfo).Error
        if err != nil </span><span class="cov8" title="1">{
                return fileInfo, fmt.Errorf("could not lookup root directory")
        }</span>

        <span class="cov8" title="1">if !fileInfo.IsDir </span><span class="cov0" title="0">{
                return fileInfo, fmt.Errorf("root directory is not a directory")
        }</span>

        <span class="cov8" title="1">return fileInfo, nil</span>
}

func (f *fileService) lookup(tx *gorm.DB, path string) ([]FileInfo, error) <span class="cov8" title="1">{
        var fileInfos []FileInfo

        rootDir, err := f.lookupRoot(tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not lookup root directory: %w", err)
        }</span>

        <span class="cov8" title="1">fileInfos = append(fileInfos, rootDir)

        if strings.TrimSpace(path) == "/" </span><span class="cov8" title="1">{
                return fileInfos, nil
        }</span>

        <span class="cov8" title="1">cleanPath, _, _, err := f.cleanPath(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not clean path: %w", err)
        }</span>

        <span class="cov8" title="1">cleanPath = strings.TrimPrefix(cleanPath, "/")
        parts := strings.Split(cleanPath, "/")
        f.Opts.Logger.WithFields(logrus.Fields{
                "path":       path,
                "clean-path": cleanPath,
                "parts":      parts,
        }).Debug("Cleaned path")

        currentDir := rootDir

        for _, part := range parts </span><span class="cov8" title="1">{
                child, found := currentDir.FindChild(part)
                if !found </span><span class="cov0" title="0">{
                        return []FileInfo{},
                                fmt.Errorf(
                                        "could not find child '%s' of path '%s' in %v",
                                        part,
                                        path,
                                        currentDir)
                }</span>

                <span class="cov8" title="1">fileInfos = append(fileInfos, child)
                currentDir = child
                err := tx.Model(&amp;currentDir).Preload(clause.Associations).Error
                if err != nil </span><span class="cov0" title="0">{
                        return []FileInfo{}, fmt.Errorf("could not preload child %v", currentDir)
                }</span>

                <span class="cov8" title="1">if !currentDir.IsDir </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return fileInfos, nil</span>
}

func (f *fileService) computePrivileges(p Principal, fileInfos ...FileInfo) Privileges <span class="cov8" title="1">{
        hasPermissionsList := []HasPermissions{}

        for _, fileInfo := range fileInfos </span><span class="cov8" title="1">{
                hasPermissionsList = append(hasPermissionsList, &amp;fileInfo)
        }</span>

        <span class="cov8" title="1">return p.ComputePrivileges(hasPermissionsList...)</span>
}

func (f *fileService) canRead(p Principal, fileInfos ...FileInfo) bool <span class="cov8" title="1">{
        return f.computePrivileges(p, fileInfos...).Read
}</span>

func (f *fileService) canWrite(p Principal, fileInfos ...FileInfo) bool <span class="cov8" title="1">{
        return f.computePrivileges(p, fileInfos...).Write
}</span>

func (f *fileService) canDelete(p Principal, fileInfos ...FileInfo) bool <span class="cov8" title="1">{
        return f.computePrivileges(p, fileInfos...).Delete
}</span>

func (f *fileService) Stat(p Principal, path string) (FileInfo, error) <span class="cov8" title="1">{
        var fileInfo FileInfo
        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                fileInfos, err := f.lookup(tx, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to lookup %s: %w", path, err)
                }</span>

                <span class="cov8" title="1">if !f.canRead(p, fileInfos...) </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission denied for %s", path)
                }</span>

                <span class="cov8" title="1">fileInfo = fileInfos[len(fileInfos)-1]

                return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return FileInfo{}, fmt.Errorf("failed to stat %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">return fileInfo, nil</span>
}

func (f *fileService) List(p Principal, path string) ([]FileInfo, error) <span class="cov8" title="1">{
        var children []FileInfo
        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                fileInfos, err := f.lookup(tx, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to lookup dirs: %w", err)
                }</span>

                <span class="cov8" title="1">if !f.canRead(p, fileInfos...) </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission denied for %s", path)
                }</span>

                <span class="cov8" title="1">target := fileInfos[len(fileInfos)-1]
                children = target.Children

                return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list files: %w", err)
        }</span>

        <span class="cov8" title="1">sort.Slice(children, func(i, j int) bool </span><span class="cov0" title="0">{
                return children[i].Name &lt; children[j].Name
        }</span>)

        <span class="cov8" title="1">return children, nil</span>
}

func (f *fileService) CreateFile(p Principal, path string, perms Permissions) (FileInfo, error) <span class="cov8" title="1">{
        var fileInfo FileInfo

        _, parentPath, name, err := f.cleanPath(path)
        if err != nil </span><span class="cov0" title="0">{
                return FileInfo{}, fmt.Errorf("invalid path '%s': %w", path, err)
        }</span>

        <span class="cov8" title="1">err = f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                parents, err := f.lookup(tx, parentPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to lookup parent: %w", err)
                }</span>

                <span class="cov8" title="1">if len(parents) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no parent found")
                }</span>

                <span class="cov8" title="1">parent := parents[len(parents)-1]

                if !f.canWrite(p, parent) </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission denied")
                }</span>

                <span class="cov8" title="1">fileInfo = FileInfo{
                        Name:        name,
                        IsDir:       false,
                        ParentID:    &amp;parent.ID,
                        Permissions: perms,
                }

                err = tx.Create(&amp;fileInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return FileInfo{}, fmt.Errorf("failed to create file '%s': %w", path, err)
        }</span>

        <span class="cov8" title="1">return fileInfo, nil</span>
}

func (f *fileService) CreateDir(p Principal, path string, perms Permissions) (FileInfo, error) <span class="cov0" title="0">{
        var fileInfo FileInfo

        _, parentPath, name, err := f.cleanPath(path)
        if err != nil </span><span class="cov0" title="0">{
                return FileInfo{}, fmt.Errorf("invalid path '%s': %w", path, err)
        }</span>

        <span class="cov0" title="0">err = f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                parents, err := f.lookup(tx, parentPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to lookup parent: %w", err)
                }</span>

                <span class="cov0" title="0">if len(parents) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no parent found")
                }</span>

                <span class="cov0" title="0">parent := parents[len(parents)-1]

                if !f.canWrite(p, parent) </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission denied")
                }</span>

                <span class="cov0" title="0">fileInfo = FileInfo{
                        Name:        name,
                        IsDir:       true,
                        ParentID:    &amp;parent.ID,
                        Permissions: perms,
                }

                err = tx.Create(&amp;fileInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return FileInfo{}, fmt.Errorf("failed to create dir '%s': %w", path, err)
        }</span>

        <span class="cov0" title="0">return fileInfo, nil</span>
}

func (f *fileService) DeleteFile(p Principal, path string) error <span class="cov8" title="1">{
        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                fileInfos, err := f.lookup(tx, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to lookup file: %w", err)
                }</span>

                <span class="cov8" title="1">if !f.canDelete(p, fileInfos...) </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission denied")
                }</span>

                <span class="cov8" title="1">if len(fileInfos) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no file found")
                }</span>

                <span class="cov8" title="1">fileInfo := fileInfos[len(fileInfos)-1]

                if fileInfo.IsDir </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't delete a directory with this call")
                }</span>

                <span class="cov8" title="1">err = tx.Delete(&amp;fileInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete file: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (f *fileService) DeleteDir(p Principal, path string) error <span class="cov0" title="0">{
        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                fileInfos, err := f.lookup(tx, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to lookup directory: %w", err)
                }</span>

                <span class="cov0" title="0">if !f.canDelete(p, fileInfos...) </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission denied")
                }</span>

                <span class="cov0" title="0">if len(fileInfos) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no directory found")
                }</span>

                <span class="cov0" title="0">fileInfo := fileInfos[len(fileInfos)-1]

                if !fileInfo.IsDir </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't delete a file with this call")
                }</span>

                <span class="cov0" title="0">if len(fileInfo.Children) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("directory is not empty")
                }</span>
                <span class="cov0" title="0">err = tx.Delete(&amp;fileInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete directory %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (f *fileService) GetBlockInfos(p Principal, path string) ([]BlockInfo, error) <span class="cov0" title="0">{
        var blockInfos []BlockInfo
        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                fileInfos, err := f.lookup(tx, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to lookup file: %w", err)
                }</span>

                <span class="cov0" title="0">if !f.canRead(p, fileInfos...) </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission denied")
                }</span>

                <span class="cov0" title="0">if len(fileInfos) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no file found")
                }</span>

                <span class="cov0" title="0">blockInfos = fileInfos[len(fileInfos)-1].BlockInfos

                return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get block infos for file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return blockInfos, nil</span>
}

func (f *fileService) NotifyBlockPresent(n *proto.NotifyBlockPresentRequest) error <span class="cov0" title="0">{
        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                blockInfo := BlockInfo{}

                fileInfos, err := f.lookup(tx, n.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("file not found: %w", err)
                }</span>

                <span class="cov0" title="0">if len(fileInfos) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("file not found")
                }</span>

                <span class="cov0" title="0">fileInfo := fileInfos[len(fileInfos)-1]

                if fileInfo.IsDir </span><span class="cov0" title="0">{
                        return fmt.Errorf("path is a directory")
                }</span>

                <span class="cov0" title="0">err = tx.Where(
                        &amp;BlockInfo{ID: n.GetBlockId()}).
                        Attrs(&amp;BlockInfo{
                                ID:         n.GetBlockId(),
                                FileInfoID: fileInfo.ID,
                                Sequence:   n.GetSequence(),
                                Length:     n.GetLength(),
                                CRC:        n.GetCrc(),
                        }).FirstOrCreate(&amp;blockInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not get or create block: %w", err)
                }</span>

                <span class="cov0" title="0">if blockInfo.Sequence != n.GetSequence() </span><span class="cov0" title="0">{
                        return fmt.Errorf("sequence %d does not match %d", n.GetSequence(), blockInfo.Sequence)
                }</span>

                <span class="cov0" title="0">if blockInfo.Length != n.GetLength() </span><span class="cov0" title="0">{
                        return fmt.Errorf("length %d does not match %d", n.GetLength(), blockInfo.Length)
                }</span>

                <span class="cov0" title="0">if blockInfo.CRC != n.GetCrc() </span><span class="cov0" title="0">{
                        return fmt.Errorf("crc %d does not match %d", n.GetCrc(), blockInfo.CRC)
                }</span>

                <span class="cov0" title="0">if !blockInfo.ContainsHost(n.GetHost()) </span><span class="cov0" title="0">{
                        location := Location{
                                BlockInfoID: blockInfo.ID,
                                Host:        n.Host,
                        }

                        err = tx.Create(&amp;location).Error
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not create location: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "failed to notify block '%s' exists for path '%s' at host '%s': %w",
                        n.GetBlockId(),
                        n.GetPath(),
                        n.GetHost(),
                        err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (f *fileService) NotifyBlockAdded(n *proto.NotifyBlockAddedRequest) error <span class="cov0" title="0">{
        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                blockInfo := BlockInfo{}

                fileInfos, err := f.lookup(tx, n.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("file not found: %w", err)
                }</span>

                <span class="cov0" title="0">if len(fileInfos) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("file not found")
                }</span>

                <span class="cov0" title="0">fileInfo := fileInfos[len(fileInfos)-1]

                if fileInfo.IsDir </span><span class="cov0" title="0">{
                        return fmt.Errorf("path is a directory")
                }</span>

                <span class="cov0" title="0">err = tx.Where(
                        &amp;BlockInfo{ID: n.GetBlockId()}).
                        Attrs(&amp;BlockInfo{
                                ID:         n.GetBlockId(),
                                FileInfoID: fileInfo.ID,
                                Sequence:   n.GetSequence(),
                                Length:     n.GetLength(),
                                CRC:        n.GetCrc(),
                        }).FirstOrCreate(&amp;blockInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not get or create block: %w", err)
                }</span>

                <span class="cov0" title="0">if blockInfo.Sequence != n.GetSequence() </span><span class="cov0" title="0">{
                        return fmt.Errorf("sequence %d does not match %d", n.GetSequence(), blockInfo.Sequence)
                }</span>

                <span class="cov0" title="0">if blockInfo.Length != n.GetLength() </span><span class="cov0" title="0">{
                        return fmt.Errorf("length %d does not match %d", n.GetLength(), blockInfo.Length)
                }</span>

                <span class="cov0" title="0">if blockInfo.CRC != n.GetCrc() </span><span class="cov0" title="0">{
                        return fmt.Errorf("crc %d does not match %d", n.GetCrc(), blockInfo.CRC)
                }</span>

                <span class="cov0" title="0">location := Location{
                        BlockInfoID: blockInfo.ID,
                        Host:        n.Host,
                }

                err = tx.Create(&amp;location).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not create location: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "failed to notify block '%s' added for path '%s' at host '%s': %w",
                        n.GetBlockId(),
                        n.GetPath(),
                        n.GetHost(),
                        err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
func (f *fileService) NotifyBlockRemoved(n *proto.NotifyBlockRemovedRequest) error <span class="cov0" title="0">{
        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                blockInfo := BlockInfo{}

                fileInfos, err := f.lookup(tx, n.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("file not found: %w", err)
                }</span>

                <span class="cov0" title="0">if len(fileInfos) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("file not found")
                }</span>

                <span class="cov0" title="0">fileInfo := fileInfos[len(fileInfos)-1]

                if fileInfo.IsDir </span><span class="cov0" title="0">{
                        return fmt.Errorf("path is a directory")
                }</span>

                <span class="cov0" title="0">err = tx.Where(
                        &amp;BlockInfo{ID: n.GetBlockId()}).First(&amp;blockInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not get block: %w", err)
                }</span>

                <span class="cov0" title="0">for _, location := range blockInfo.Locations </span><span class="cov0" title="0">{
                        if location.Host == n.GetHost() </span><span class="cov0" title="0">{
                                err = tx.Delete(&amp;location).Error
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("could not delete location")
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "failed to notify block '%s' at path '%s' removed from host '%s': %w",
                        n.GetBlockId(),
                        n.GetPath(),
                        n.GetHost(),
                        err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (f *fileService) NodeRemoved(host string) error <span class="cov0" title="0">{
        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                blockInfos := []BlockInfo{}

                err := tx.Find(&amp;blockInfos).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not get blocks: %w", err)
                }</span>

                <span class="cov0" title="0">for _, blockInfo := range blockInfos </span><span class="cov0" title="0">{
                        for _, location := range blockInfo.Locations </span><span class="cov0" title="0">{
                                if location.Host == host </span><span class="cov0" title="0">{
                                        err = tx.Delete(&amp;location).Error
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("could not delete location %v: %w", location, err)
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not remove node '%s': %w", host, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (f *fileService) GetAllBlockInfos() ([]BlockInfo, error) <span class="cov0" title="0">{
        blockInfos := []BlockInfo{}

        err := f.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                err := tx.Find(&amp;blockInfos).Error
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return blockInfos, fmt.Errorf("could not get block infos: %w", err)
        }</span>

        <span class="cov0" title="0">return blockInfos, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package name

import (
        "context"
        "errors"
        "fmt"
        "github.com/cirglo.com/dfs/pkg/proto"
        "github.com/sirupsen/logrus"
        "math/rand"
        "slices"
        "sync"
        "time"
)

type HealingOpts struct {
        Logger            *logrus.Logger
        NumReplicas       uint
        FileService       FileService
        NodeExpiration    time.Duration
        ConnectionFactory proto.ConnectionFactory
}

func (o *HealingOpts) Validate() error <span class="cov0" title="0">{
        if o.Logger == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("logger is required")
        }</span>

        <span class="cov0" title="0">if o.NumReplicas &gt;= 255 </span><span class="cov0" title="0">{
                return fmt.Errorf("number of replicas must be less than 256")
        }</span>

        <span class="cov0" title="0">if o.NumReplicas == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("num replicas is required")
        }</span>

        <span class="cov0" title="0">if o.FileService == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("fileService is required")
        }</span>

        <span class="cov0" title="0">if o.ConnectionFactory == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection factory is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type HealingService interface {
        NotifyNodeAlive(host string, at time.Time)
        Heal(since time.Time) error
}

type healingService struct {
        Opts  HealingOpts
        Nodes map[string]time.Time
        Lock  sync.RWMutex
}

var _ HealingService = &amp;healingService{}

func NewHealingService(opts HealingOpts) (HealingService, error) <span class="cov0" title="0">{
        err := opts.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid options: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;healingService{
                Opts:  opts,
                Nodes: map[string]time.Time{},
                Lock:  sync.RWMutex{},
        }, nil</span>
}

func (s *healingService) NotifyNodeAlive(host string, at time.Time) <span class="cov0" title="0">{
        s.Lock.Lock()
        defer s.Lock.Unlock()

        s.Nodes[host] = at
}</span>

func (s *healingService) Heal(since time.Time) error <span class="cov0" title="0">{
        removedHosts := s.removeExpiredNodes(since)
        var allErrors []error
        for _, host := range removedHosts </span><span class="cov0" title="0">{
                s.Opts.Logger.WithField("host", host).Info("Removing expired node")
                err := s.Opts.FileService.NodeRemoved(host)
                allErrors = append(allErrors, err)
        }</span>

        <span class="cov0" title="0">blockInfos, err := s.Opts.FileService.GetAllBlockInfos()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not get block infos: %w", err)
        }</span>

        <span class="cov0" title="0">currentLocations := map[string][]string{}

        for _, blockInfo := range blockInfos </span><span class="cov0" title="0">{
                id := blockInfo.ID
                currentLocations[id] = []string{}

                for _, location := range blockInfo.Locations </span><span class="cov0" title="0">{
                        host := location.Host
                        currentLocations[id] = append(currentLocations[id], host)
                }</span>
        }

        <span class="cov0" title="0">for id := range currentLocations </span><span class="cov0" title="0">{
                slices.Sort(currentLocations[id])
        }</span>
        <span class="cov0" title="0">for _, blockInfo := range blockInfos </span><span class="cov0" title="0">{
                s.checkBlock(blockInfo, currentLocations[blockInfo.ID])
        }</span>

        <span class="cov0" title="0">return errors.Join(allErrors...)</span>
}

func (s *healingService) removeExpiredNodes(since time.Time) []string <span class="cov0" title="0">{
        s.Lock.Lock()
        defer s.Lock.Unlock()

        var toRemove []string

        for host, at := range s.Nodes </span><span class="cov0" title="0">{
                expiration := at.Add(s.Opts.NodeExpiration)
                if expiration.Before(since) </span><span class="cov0" title="0">{
                        toRemove = append(toRemove, host)
                }</span>
        }

        <span class="cov0" title="0">for _, host := range toRemove </span><span class="cov0" title="0">{
                s.Opts.Logger.WithField("host", host).Info("node is dead")
                delete(s.Nodes, host)
        }</span>

        <span class="cov0" title="0">return toRemove</span>
}

func (s *healingService) checkBlock(blockInfo BlockInfo, currentLocations []string) <span class="cov0" title="0">{
        s.Lock.RLock()
        defer s.Lock.RUnlock()

        neededCount := int(s.Opts.NumReplicas) - len(blockInfo.Locations)

        if neededCount &gt; 0 </span><span class="cov0" title="0">{
                s.Opts.Logger.WithFields(logrus.Fields{
                        "block-id":                  blockInfo.ID,
                        "mandatory-replicas-count":  s.Opts.NumReplicas,
                        "replicas-count":            len(blockInfo.Locations),
                        "needed-new-replicas-count": neededCount,
                }).Info("Block needs more replicas")
                destinations, found := s.findDestinations(currentLocations, neededCount)
                if found </span><span class="cov0" title="0">{
                        for _, destination := range destinations </span><span class="cov0" title="0">{
                                if len(currentLocations) == 0 </span><span class="cov0" title="0">{
                                        s.Opts.Logger.WithField("block-id", blockInfo.ID).Warn("No current locations available to select a source for block replication")
                                        continue</span>
                                }
                                <span class="cov0" title="0">source := currentLocations[rand.Intn(len(currentLocations))]
                                go s.copyBlock(blockInfo.ID, source, destination)</span>
                        }
                }
        }
}

func (s *healingService) findDestinations(currentLocations []string, count int) ([]string, bool) <span class="cov0" title="0">{
        var candidates []string

        for location := range s.Nodes </span><span class="cov0" title="0">{
                _, found := slices.BinarySearch(currentLocations, location)
                if !found </span><span class="cov0" title="0">{
                        candidates = append(candidates, location)
                }</span>
        }

        <span class="cov0" title="0">if len(candidates) &lt; count </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">shuffle(candidates)

        return candidates[:count], true</span>
}

func (s *healingService) copyBlock(blockId string, source string, dest string) <span class="cov0" title="0">{
        connection, err := s.Opts.ConnectionFactory.CreateConnection(source)
        if err != nil </span><span class="cov0" title="0">{
                s.Opts.Logger.WithError(err).WithField("host", dest).Error("could not create connection")
                return
        }</span>
        <span class="cov0" title="0">defer connection.Close()

        client := proto.NewNodeClient(connection)

        s.Opts.Logger.WithFields(logrus.Fields{
                "source":      source,
                "destination": dest,
                "block-id":    blockId,
        }).Info("Copying block")
        _, err = client.CopyBlock(context.Background(), &amp;proto.CopyBlockRequest{
                Id:          blockId,
                Destination: dest,
        })
        if err != nil </span><span class="cov0" title="0">{
                s.Opts.Logger.
                        WithError(err).
                        WithFields(logrus.Fields{
                                "block-id":    blockId,
                                "source":      source,
                                "destination": dest,
                        }).
                        Error("unable to copy block")
        }</span> else<span class="cov0" title="0"> {
                s.Opts.Logger.WithFields(logrus.Fields{
                        "source":      source,
                        "destination": dest,
                        "block-id":    blockId,
                }).Info("block copied")
        }</span>
}

func shuffle(slice []string) <span class="cov0" title="0">{
        for i := range slice </span><span class="cov0" title="0">{
                j := rand.Intn(len(slice))
                slice[i], slice[j] = slice[j], slice[i]
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package name

import (
        "context"
        "github.com/cirglo.com/dfs/pkg/proto"
        "time"
)

type NotificationServer struct {
        proto.UnimplementedNotificationServer
        FileService    FileService
        HealingService HealingService
}

var _ proto.NotificationServer = (*NotificationServer)(nil)

func (n NotificationServer) NotifyBlockPresent(ctx context.Context, request *proto.NotifyBlockPresentRequest) (*proto.NotifyBlockPresentResponse, error) <span class="cov0" title="0">{
        n.HealingService.NotifyNodeAlive(request.Host, time.Now())
        err := n.FileService.NotifyBlockPresent(request)
        return &amp;proto.NotifyBlockPresentResponse{}, err
}</span>

func (n NotificationServer) NotifyBlockAdded(ctx context.Context, request *proto.NotifyBlockAddedRequest) (*proto.NotifyBlockAddedResponse, error) <span class="cov0" title="0">{
        n.HealingService.NotifyNodeAlive(request.Host, time.Now())
        err := n.FileService.NotifyBlockAdded(request)
        return &amp;proto.NotifyBlockAddedResponse{}, err
}</span>

func (n NotificationServer) NotifyBlockRemoved(ctx context.Context, request *proto.NotifyBlockRemovedRequest) (*proto.NotifyBlockRemovedResponse, error) <span class="cov0" title="0">{
        n.HealingService.NotifyNodeAlive(request.Host, time.Now())
        err := n.FileService.NotifyBlockRemoved(request)
        return &amp;proto.NotifyBlockRemovedResponse{}, err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package name

import (
        "fmt"
        "gorm.io/gorm"
        "strings"
)

type HasPermissions interface {
        GetPermissions() Permissions
}

type Permission struct {
        Read   bool `gorm:"not null"`
        Write  bool `gorm:"not null"`
        Delete bool `gorm:"not null"`
}

type Permissions struct {
        Owner           string     `gorm:"not null"`
        Group           string     `gorm:"not null"`
        OwnerPermission Permission `gorm:"embedded;embeddedPrefix:owner_"`
        GroupPermission Permission `gorm:"embedded;embeddedPrefix:group_"`
        OtherPermission Permission `gorm:"embedded;embeddedPrefix:other_"`
}

func (p *Permissions) BeforeSave(_ *gorm.DB) error <span class="cov0" title="0">{
        p.Owner = strings.TrimSpace(p.Owner)
        p.Group = strings.TrimSpace(p.Group)

        if len(p.Owner) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("owner is empty")
        }</span>

        <span class="cov0" title="0">if len(p.Group) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("group is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package name

type Principal interface {
        ComputePrivileges(hasPermissionsList ...HasPermissions) Privileges
}

type principal struct {
        user   string
        groups []string
}

func (p *principal) User() string <span class="cov0" title="0">{
        return p.user
}</span>

func (p *principal) Groups() []string <span class="cov0" title="0">{
        return p.groups
}</span>

func NewPrincipal(user User) Principal <span class="cov0" title="0">{
        var groups []string

        for _, group := range user.Groups </span><span class="cov0" title="0">{
                groups = append(groups, group.Name)
        }</span>

        <span class="cov0" title="0">return &amp;principal{
                user:   user.Name,
                groups: groups,
        }</span>
}

func (p principal) ComputePrivileges(hasPermissionList ...HasPermissions) Privileges <span class="cov0" title="0">{
        canRead := false
        canWrite := false
        canDelete := false

        for _, hasPermissions := range hasPermissionList </span><span class="cov0" title="0">{
                permissions := hasPermissions.GetPermissions()

                if permissions.OtherPermission.Read </span><span class="cov0" title="0">{
                        canRead = true
                }</span>

                <span class="cov0" title="0">if permissions.OtherPermission.Write </span><span class="cov0" title="0">{
                        canWrite = true
                }</span>

                <span class="cov0" title="0">if permissions.OtherPermission.Delete </span><span class="cov0" title="0">{
                        canDelete = true
                }</span>

                <span class="cov0" title="0">if permissions.Owner == p.user </span><span class="cov0" title="0">{
                        if permissions.OwnerPermission.Read </span><span class="cov0" title="0">{
                                canRead = true
                        }</span>

                        <span class="cov0" title="0">if permissions.OwnerPermission.Write </span><span class="cov0" title="0">{
                                canWrite = true
                        }</span>

                        <span class="cov0" title="0">if permissions.OwnerPermission.Delete </span><span class="cov0" title="0">{
                                canDelete = true
                        }</span>
                }

                <span class="cov0" title="0">for _, group := range p.groups </span><span class="cov0" title="0">{
                        if permissions.Group == group </span><span class="cov0" title="0">{
                                if permissions.GroupPermission.Read </span><span class="cov0" title="0">{
                                        canRead = true
                                }</span>

                                <span class="cov0" title="0">if permissions.GroupPermission.Write </span><span class="cov0" title="0">{
                                        canWrite = true
                                }</span>

                                <span class="cov0" title="0">if permissions.GroupPermission.Delete </span><span class="cov0" title="0">{
                                        canDelete = true
                                }</span>

                                <span class="cov0" title="0">if canRead &amp;&amp; canWrite &amp;&amp; canDelete </span><span class="cov0" title="0">{
                                        return Privileges{
                                                Read:   true,
                                                Write:  true,
                                                Delete: true,
                                        }
                                }</span>
                        }
                }

                <span class="cov0" title="0">if canRead &amp;&amp; canWrite &amp;&amp; canDelete </span><span class="cov0" title="0">{
                        return Privileges{
                                Read:   true,
                                Write:  true,
                                Delete: true,
                        }
                }</span>
        }

        <span class="cov0" title="0">return Privileges{
                Read:   canRead,
                Write:  canWrite,
                Delete: canDelete,
        }</span>
}

type rootPrincipal struct {
}

func NewRootPrincipal() Principal <span class="cov8" title="1">{
        return &amp;rootPrincipal{}
}</span>

func (p rootPrincipal) ComputePrivileges(_ ...HasPermissions) Privileges <span class="cov8" title="1">{
        return Privileges{
                Read:   true,
                Write:  true,
                Delete: true,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package name

type Privileges struct {
        Read   bool
        Write  bool
        Delete bool
}

func (p Privileges) Union(o Privileges) Privileges <span class="cov0" title="0">{
        return Privileges{
                Read:   p.Read &amp;&amp; o.Read,
                Write:  p.Write &amp;&amp; o.Write,
                Delete: p.Delete &amp;&amp; o.Delete,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package name

import (
        "crypto/rand"
        "database/sql"
        "encoding/base64"
        "fmt"
        "github.com/sirupsen/logrus"
        "time"

        "gorm.io/gorm"
)

type User struct {
        Name           string    `gorm:"column:name;primaryKey;not null"`
        CreatedAt      time.Time `gorm:"column:created_at"`
        UpdatedAt      time.Time `gorm:"column:updated_at"`
        HashedPassword string    `gorm:"column:hp;not null"`
        Groups         []*Group  `gorm:"many2many:user_group;"`
        Tokens         []*Token  `gorm:"foreignKey:user_name;references:name"`
}

type Group struct {
        Name      string    `gorm:"column:name;primaryKey;not null"`
        CreatedAt time.Time `gorm:"column:created_at"`
        UpdatedAt time.Time `gorm:"column:updated_at"`
        Users     []*User   `gorm:"many2many:user_groups"`
}

type Token struct {
        ID        uint64    `gorm:"column:id;autoIncrement;primaryKey"`
        CreatedAt time.Time `gorm:"column:created_at"`
        UpdatedAt time.Time `gorm:"column:updated_at"`
        ExpiresAt time.Time `gorm:"column:expired_at; not null"`
        Value     string    `gorm:"column:value;not null"`
        User      User      `gorm:"column:user_name;foreignKey:name;not null"`
}

func (t *Token) IsExpired() bool <span class="cov0" title="0">{
        return t.ExpiresAt.Before(time.Now())
}</span>

type SecurityService interface {
        CreateUser(user User) error
        DeleteUser(userName string) error
        GetUser(userName string) (User, error)
        GetAllUsers() ([]User, error)
        GetGroup(groupName string) (Group, error)
        GetAllGroups() ([]Group, error)
        CreateGroup(group Group) error
        DeleteGroup(groupName string) error
        AddUserToGroup(userName string, groupName string) error
        RemoveUserFromGroup(userName string, groupName string) error
        AuthenticateUser(userName string, password string) (string, error)
        ChangeUserPassword(userName string, newPassword string) error
        Logout(token string) error
        LookupUserByToken(token string) (User, error)
}

type SecurityServiceOpts struct {
        Logger           *logrus.Logger
        DB               *gorm.DB
        TokenExperiation time.Duration
}

func (o *SecurityServiceOpts) Validate() error <span class="cov0" title="0">{
        if o.Logger == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("logger is required")
        }</span>
        <span class="cov0" title="0">if o.DB == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db is required")
        }</span>
        <span class="cov0" title="0">if o.TokenExperiation == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("token expiration is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type securityService struct {
        Opts SecurityServiceOpts
}

func NewSecurityService(opts SecurityServiceOpts) (SecurityService, error) <span class="cov0" title="0">{
        if err := opts.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("options are invalid: %w", err)
        }</span>
        <span class="cov0" title="0">s := &amp;securityService{
                Opts: opts,
        }
        return s, nil</span>
}

func (s *securityService) CreateUser(user User) error <span class="cov0" title="0">{
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if user already exists
                existingUser := User{}
                tx.Where("name = ?", user.Name).First(&amp;existingUser)
                if tx.Error != nil &amp;&amp; tx.RowsAffected &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("user %s already exists", user.Name)
                }</span>

                // Create user
                <span class="cov0" title="0">tx.Create(&amp;user)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create user: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *securityService) DeleteUser(userName string) error <span class="cov0" title="0">{
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if user exists
                user := User{}
                tx.Where("name = ?", userName).First(&amp;user)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("user %s not found", userName)
                }</span>

                // Delete user
                <span class="cov0" title="0">tx.Delete(&amp;user)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete user: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *securityService) GetUser(userName string) (User, error) <span class="cov0" title="0">{
        user := User{}
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if user exists
                tx.Where("name = ?", userName).First(&amp;user)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("user %s not found", userName)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (s *securityService) GetAllUsers() ([]User, error) <span class="cov0" title="0">{
        users := []User{}
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Get all users
                tx.Find(&amp;users)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get users: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

func (s *securityService) GetGroup(groupName string) (Group, error) <span class="cov0" title="0">{
        group := Group{}
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if group exists
                tx.Where("name = ?", groupName).First(&amp;group)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("group %s not found", groupName)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return Group{}, fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return group, nil</span>
}

func (s *securityService) GetAllGroups() ([]Group, error) <span class="cov0" title="0">{
        groups := []Group{}
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Get all groups
                tx.Find(&amp;groups)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get groups: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return groups, nil</span>
}

func (s *securityService) CreateGroup(group Group) error <span class="cov0" title="0">{
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if group already exists
                existingGroup := Group{}
                tx.Where("name = ?", group.Name).First(&amp;existingGroup)
                if tx.Error != nil &amp;&amp; tx.RowsAffected &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("group %s already exists", group.Name)
                }</span>

                // Create group
                <span class="cov0" title="0">tx.Create(&amp;group)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create group: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *securityService) DeleteGroup(groupName string) error <span class="cov0" title="0">{
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if group exists
                group := Group{}
                tx.Where("name = ?", groupName).First(&amp;group)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("group %s not found", groupName)
                }</span>

                // Delete group
                <span class="cov0" title="0">tx.Delete(&amp;group)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete group: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *securityService) AddUserToGroup(userName string, groupName string) error <span class="cov0" title="0">{
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if group exists
                group := Group{}
                tx.Where("name = ?", groupName).First(&amp;group)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("group %s not found", groupName)
                }</span>

                // Check if user exists
                <span class="cov0" title="0">user := User{}
                tx.Where("name = ?", userName).First(&amp;user)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("user %s not found", userName)
                }</span>

                <span class="cov0" title="0">err := tx.Model(&amp;group).Association("Users").Append(&amp;user)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add user to group: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *securityService) RemoveUserFromGroup(userName string, groupName string) error <span class="cov0" title="0">{
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if group exists
                group := Group{}
                tx.Where("name = ?", groupName).First(&amp;group)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("group %s not found", groupName)
                }</span>

                // Check if user exists
                <span class="cov0" title="0">user := User{}
                tx.Where("name = ?", userName).First(&amp;user)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("user %s not found", userName)
                }</span>

                <span class="cov0" title="0">err := tx.Model(&amp;group).Association("Users").Delete(&amp;user)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove user from group: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *securityService) AuthenticateUser(userName string, password string) (string, error) <span class="cov0" title="0">{
        var t string
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                user := User{}
                tx.Where("name = ?", userName).First(&amp;user)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("user %s not found", userName)
                }</span>

                <span class="cov0" title="0">if user.HashedPassword != password </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid password for user %s", userName)
                }</span>

                // Generate a token
                <span class="cov0" title="0">tokenBytes := make([]byte, 1024)
                _, err := rand.Read(tokenBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not create token: %w", err)
                }</span>
                <span class="cov0" title="0">tokenString := base64.StdEncoding.EncodeToString(tokenBytes)
                token := Token{
                        Value:     tokenString,
                        User:      user,
                        ExpiresAt: time.Now().Add(s.Opts.TokenExperiation),
                }

                tx.Create(&amp;token)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create token: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">t = tokenString

                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return t, nil</span>
}

func (s *securityService) ChangeUserPassword(userName string, newPassword string) error <span class="cov0" title="0">{
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if user exists
                user := User{}
                tx.Where("name = ?", userName).First(&amp;user)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("user %s not found", userName)
                }</span>

                // Update password
                <span class="cov0" title="0">user.HashedPassword = newPassword
                tx.Save(&amp;user)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update user password: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *securityService) Logout(token string) error <span class="cov0" title="0">{
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if token exists
                tokenEntity := Token{}
                tx.Where("value = ?", token).First(&amp;tokenEntity)
                if tx.Error != nil &amp;&amp; tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("token %s not found", token)
                }</span>

                // Delete token
                <span class="cov0" title="0">tx.Delete(&amp;tokenEntity)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete token: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *securityService) LookupUserByToken(token string) (User, error) <span class="cov0" title="0">{
        user := User{}
        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if token exists
                tokenEntity := Token{}
                tx.Where("value = ?", token).First(&amp;tokenEntity)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not get token: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">if tokenEntity.IsExpired() </span><span class="cov0" title="0">{
                        return fmt.Errorf("token is expired")
                }</span>

                <span class="cov0" title="0">user = tokenEntity.User

                return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("transaction failed: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (s *securityService) IsTokenValid(token string, userName string) bool <span class="cov0" title="0">{
        var valid bool = false

        err := s.Opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Check if token exists
                tokenEntity := Token{}
                tx.Where("value = ? AND user_id = (SELECT id FROM users WHERE name = ?)", token, userName).First(&amp;tokenEntity)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check token: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">if tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                        valid = false
                        return nil
                }</span>

                <span class="cov0" title="0">if !tokenEntity.IsExpired() </span><span class="cov0" title="0">{
                        valid = true
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.Opts.Logger.WithError(err).Error("failed to check token")
                return false
        }</span>

        <span class="cov0" title="0">return valid</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package name

import (
        "context"
        "fmt"
        "github.com/cirglo.com/dfs/pkg/proto"
        "github.com/sirupsen/logrus"
)

type ServerOpts struct {
        Logger          *logrus.Logger
        SecurityService SecurityService
        FileService     FileService
}

type Server struct {
        proto.UnimplementedNameServer
        Opts ServerOpts
}

func (s Server) Login(ctx context.Context, request *proto.LoginRequest) (*proto.LoginResponse, error) <span class="cov0" title="0">{
        token, err := s.Opts.SecurityService.AuthenticateUser(request.GetUser(), request.GetHashedPassword())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("login failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;proto.LoginResponse{
                Token: token,
        }, nil</span>
}

func (s Server) Logout(ctx context.Context, request *proto.LogoutRequest) (*proto.LogoutResponse, error) <span class="cov0" title="0">{
        err := s.Opts.SecurityService.Logout(request.GetToken())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("logout failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;proto.LogoutResponse{}, nil</span>
}

func convertProtoPermission(permission *proto.Permission) Permission <span class="cov0" title="0">{
        return Permission{
                Read:  permission.GetRead(),
                Write: permission.GetWrite(),
        }
}</span>

func convertProtoPermissions(permissions *proto.Permissions) Permissions <span class="cov0" title="0">{
        return Permissions{
                Owner:           permissions.GetOwner(),
                Group:           permissions.GetGroup(),
                OwnerPermission: convertProtoPermission(permissions.GetOwnerPermission()),
                GroupPermission: convertProtoPermission(permissions.GetGroupPermission()),
                OtherPermission: convertProtoPermission(permissions.GetOtherPermission()),
        }
}</span>

func convertToProtoPermission(permission Permission) *proto.Permission <span class="cov0" title="0">{
        return &amp;proto.Permission{
                Read:  permission.Read,
                Write: permission.Write,
        }
}</span>

func convertToProtoPermissions(permissions Permissions) *proto.Permissions <span class="cov0" title="0">{
        return &amp;proto.Permissions{
                Owner:           permissions.Owner,
                Group:           permissions.Group,
                OwnerPermission: convertToProtoPermission(permissions.OwnerPermission),
                GroupPermission: convertToProtoPermission(permissions.GroupPermission),
                OtherPermission: convertToProtoPermission(permissions.OtherPermission),
        }
}</span>

func (s Server) CreateFile(ctx context.Context, request *proto.CreateFileRequest) (*proto.CreateFileResponse, error) <span class="cov0" title="0">{
        user, err := s.Opts.SecurityService.LookupUserByToken(request.GetToken())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to lookup user: %w", err)
        }</span>
        <span class="cov0" title="0">principal := NewPrincipal(user)
        permissions := convertProtoPermissions(request.GetPermissions())
        _, err = s.Opts.FileService.CreateFile(principal, request.GetPath(), permissions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;proto.CreateFileResponse{}, nil</span>
}

func (s Server) CreateDir(ctx context.Context, request *proto.CreateDirRequest) (*proto.CreateDirResponse, error) <span class="cov0" title="0">{
        user, err := s.Opts.SecurityService.LookupUserByToken(request.GetToken())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to lookup user: %w", err)
        }</span>
        <span class="cov0" title="0">principal := NewPrincipal(user)
        permissions := convertProtoPermissions(request.GetPermissions())
        _, err = s.Opts.FileService.CreateDir(principal, request.GetPath(), permissions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create dir: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;proto.CreateDirResponse{}, nil</span>
}

func (s Server) DeleteFile(ctx context.Context, request *proto.DeleteFileRequest) (*proto.DeleteFileResponse, error) <span class="cov0" title="0">{
        user, err := s.Opts.SecurityService.LookupUserByToken(request.GetToken())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to lookup user: %w", err)
        }</span>
        <span class="cov0" title="0">principal := NewPrincipal(user)
        err = s.Opts.FileService.DeleteFile(principal, request.GetPath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete file: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;proto.DeleteFileResponse{}, nil</span>
}

func (s Server) DeleteDir(ctx context.Context, request *proto.DeleteDirRequest) (*proto.DeleteDirResponse, error) <span class="cov0" title="0">{
        user, err := s.Opts.SecurityService.LookupUserByToken(request.GetToken())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to lookup user: %w", err)
        }</span>
        <span class="cov0" title="0">principal := NewPrincipal(user)
        err = s.Opts.FileService.DeleteDir(principal, request.GetPath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete dir: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;proto.DeleteDirResponse{}, nil</span>
}

func convertToProtoDirEntryFile(fileInfo FileInfo, parentDir string) *proto.DirEntry <span class="cov0" title="0">{
        path := fmt.Sprintf("%s/%s", parentDir, fileInfo.Name)
        return &amp;proto.DirEntry{
                Path:        path,
                IsDir:       false,
                Permissions: convertToProtoPermissions(fileInfo.Permissions),
                CreatedAt:   fileInfo.CreatedAt.Unix(),
                ModifiedAt:  fileInfo.UpdatedAt.Unix(),
                AccessedAt:  fileInfo.UpdatedAt.Unix(),
        }
}</span>

func (s Server) List(ctx context.Context, request *proto.ListRequest) (*proto.ListResponse, error) <span class="cov0" title="0">{
        user, err := s.Opts.SecurityService.LookupUserByToken(request.GetToken())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to lookup user: %w", err)
        }</span>
        <span class="cov0" title="0">principal := NewPrincipal(user)

        fileInfos, err := s.Opts.FileService.List(principal, request.GetPath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list path '%s': %w", request.GetPath(), err)
        }</span>

        <span class="cov0" title="0">var entries []*proto.DirEntry

        for _, fileInfo := range fileInfos </span><span class="cov0" title="0">{
                entries = append(entries, convertToProtoDirEntryFile(fileInfo, request.GetPath()))
        }</span>

        <span class="cov0" title="0">return &amp;proto.ListResponse{
                Path:    request.GetPath(),
                Entries: entries,
        }, nil</span>
}

func convertToProtoStatBlockInfo(blockInfo BlockInfo) *proto.StatBlockInfo <span class="cov0" title="0">{
        return &amp;proto.StatBlockInfo{
                BlockId:  blockInfo.ID,
                Crc:      blockInfo.CRC,
                Sequence: blockInfo.Sequence,
                Length:   blockInfo.Length,
        }
}</span>

func (s Server) Stat(ctx context.Context, request *proto.StatRequest) (*proto.StatResponse, error) <span class="cov0" title="0">{
        user, err := s.Opts.SecurityService.LookupUserByToken(request.GetToken())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to lookup user: %w", err)
        }</span>
        <span class="cov0" title="0">principal := NewPrincipal(user)
        fileInfo, err := s.Opts.FileService.Stat(principal, request.GetPath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat file '%s': %w", request.GetPath(), err)
        }</span>

        <span class="cov0" title="0">blockInfos, err := s.Opts.FileService.GetBlockInfos(principal, request.GetPath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get block infos: %w", err)
        }</span>

        <span class="cov0" title="0">var protoBlockInfos []*proto.StatBlockInfo

        for _, blockInfo := range blockInfos </span><span class="cov0" title="0">{
                protoBlockInfos = append(protoBlockInfos, convertToProtoStatBlockInfo(blockInfo))
        }</span>

        <span class="cov0" title="0">return &amp;proto.StatResponse{
                Path:       request.GetPath(),
                Entry:      convertToProtoDirEntryFile(fileInfo, request.GetPath()),
                BlockInfos: protoBlockInfos,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package node

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "github.com/cirglo.com/dfs/pkg/proto"
        "github.com/sirupsen/logrus"
        "gorm.io/gorm"
        "hash/crc32"
        "os"
        "path/filepath"
        "strings"
)

type BlockService interface {
        GetBlockIds() ([]string, error)
        GetBlocks() ([]BlockInfo, error)
        WriteBlock(id string, path string, sequence uint64, data []byte) error
        DeleteBlock(id string) error
        ReadBlock(id string) ([]byte, BlockInfo, error)
        Report() error
        HealthCheck() error
        ValidateCRC() error
}

type BlockInfo struct {
        ID           string `gorm:"primaryKey;uniqueIndex:idx_block_info;not null"`
        Sequence     uint64 `gorm:"not null;uniqueIndex:idx_block_info'"`
        Length       uint32 `gorm:"not null"`
        Path         string `gorm:"not null"`
        DataFilePath string `gorm:"not null"`
        CRC          uint32 `gorm:"not null"`
}

func (bi *BlockInfo) BeforeSave(_ *gorm.DB) error <span class="cov8" title="1">{
        bi.ID = strings.TrimSpace(bi.ID)
        bi.Path = strings.TrimSpace(bi.Path)
        bi.DataFilePath = strings.TrimSpace(bi.DataFilePath)

        if len(bi.ID) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("block id is empty")
        }</span>

        <span class="cov8" title="1">if len(bi.Path) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("path is empty")
        }</span>

        <span class="cov8" title="1">if len(bi.DataFilePath) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("data file path is empty")
        }</span>

        <span class="cov8" title="1">if bi.Length == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("length is zero")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type BlockServiceOpts struct {
        Logger             *logrus.Logger
        Host               string
        DB                 *gorm.DB
        Dir                string
        NotificationClient proto.NotificationClient
}

func (o *BlockServiceOpts) Validate() error <span class="cov8" title="1">{
        if o.Logger == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("logger is required")
        }</span>

        <span class="cov8" title="1">if o.DB == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db is required")
        }</span>

        <span class="cov8" title="1">dirStat, err := os.Stat(o.Dir)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not stat dir %s: %w", o.Dir, err)
        }</span>

        <span class="cov8" title="1">if !dirStat.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("dir is not a directory: %s", o.Dir)
        }</span>

        <span class="cov8" title="1">if o.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("host is required")
        }</span>

        <span class="cov8" title="1">if o.NotificationClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("notificationClient is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type service struct {
        opts BlockServiceOpts
}

func NewBlockService(opts BlockServiceOpts) (BlockService, error) <span class="cov8" title="1">{
        err := opts.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("options are not valid: %w", err)
        }</span>

        <span class="cov8" title="1">opts.Logger.WithFields(logrus.Fields{
                "dir":  opts.Dir,
                "host": opts.Host,
        }).Info("Constructing new service")

        s := service{opts: opts}

        return &amp;s, nil</span>
}

func (s *service) GetBlockIds() ([]string, error) <span class="cov8" title="1">{
        var blockIds []string
        err := s.opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                blockInfos := []BlockInfo{}
                err := tx.Find(&amp;blockInfos).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get block ids: %w", err)
                }</span>

                <span class="cov8" title="1">for _, blockInfo := range blockInfos </span><span class="cov8" title="1">{
                        blockIds = append(blockIds, blockInfo.ID)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get block ids: %w", err)
        }</span>

        <span class="cov8" title="1">return blockIds, nil</span>
}

func (s *service) GetBlocks() ([]BlockInfo, error) <span class="cov8" title="1">{
        var blockInfos []BlockInfo

        err := s.opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                err := tx.Find(&amp;blockInfos).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get blocks: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get blocks: %w", err)
        }</span>

        <span class="cov8" title="1">return blockInfos, nil</span>
}

func (s *service) WriteBlock(id string, path string, sequence uint64, data []byte) error <span class="cov8" title="1">{
        trimmedId := strings.TrimSpace(id)
        if len(trimmedId) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("block id is empty")
        }</span>
        <span class="cov8" title="1">dataFilePath := filepath.Join(s.opts.Dir, trimmedId)
        err := os.WriteFile(dataFilePath, data, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write data file to path %s: %w", dataFilePath, err)
        }</span>

        <span class="cov8" title="1">blockInfo := BlockInfo{
                ID:           trimmedId,
                Sequence:     sequence,
                Length:       uint32(len(data)),
                Path:         path,
                DataFilePath: dataFilePath,
                CRC:          crc32.ChecksumIEEE(data),
        }

        err = s.opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                err := tx.Create(&amp;blockInfo).Error
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to create block info: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to write block: %w", err)
        }</span>

        <span class="cov8" title="1">_, err = s.opts.NotificationClient.NotifyBlockAdded(context.Background(), &amp;proto.NotifyBlockAddedRequest{
                Host:     s.opts.Host,
                BlockId:  blockInfo.ID,
                Path:     blockInfo.Path,
                Crc:      blockInfo.CRC,
                Sequence: blockInfo.Sequence,
                Length:   blockInfo.Length,
        })
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to notify blocks added: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *service) DeleteBlock(id string) error <span class="cov8" title="1">{
        var path string
        err := s.opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                blockInfo := BlockInfo{
                        ID: id,
                }
                err := tx.First(&amp;blockInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get block info: %w", err)
                }</span>
                <span class="cov8" title="1">path = blockInfo.DataFilePath
                err = tx.Delete(&amp;blockInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete block info: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete block info: %w", err)
        }</span>

        <span class="cov8" title="1">_, err = s.opts.NotificationClient.NotifyBlockRemoved(context.Background(), &amp;proto.NotifyBlockRemovedRequest{
                Host:    s.opts.Host,
                BlockId: id,
                Path:    path,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to notify blocks removed: %w", err)
        }</span>

        <span class="cov8" title="1">err = os.Remove(path)
        if err != nil </span><span class="cov8" title="1">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove data file: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *service) ReadBlock(id string) ([]byte, BlockInfo, error) <span class="cov8" title="1">{
        var data []byte
        var blockInfo BlockInfo
        err := s.opts.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                err := tx.Where("id = ?", id).First(&amp;blockInfo).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get block info: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, &amp;sql.TxOptions{ReadOnly: true})
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, blockInfo, fmt.Errorf("failed to get block info: %w", err)
        }</span>

        <span class="cov8" title="1">data, err = os.ReadFile(blockInfo.DataFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, blockInfo, fmt.Errorf("failed to read data file %s: %w", blockInfo.DataFilePath, err)
        }</span>

        <span class="cov8" title="1">if blockInfo.CRC != crc32.ChecksumIEEE(data) </span><span class="cov0" title="0">{
                return nil, blockInfo, fmt.Errorf("invalid checksum (mismatch)")
        }</span>

        <span class="cov8" title="1">if blockInfo.Length != uint32(len(data)) </span><span class="cov0" title="0">{
                return nil, blockInfo, fmt.Errorf("invalid length")
        }</span>

        <span class="cov8" title="1">return data, blockInfo, nil</span>
}

func (s *service) Report() error <span class="cov0" title="0">{
        blockInfos, err := s.GetBlocks()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get blocks: %w", err)
        }</span>
        <span class="cov0" title="0">var allErrors []error

        for _, blockInfo := range blockInfos </span><span class="cov0" title="0">{
                _, err = s.opts.NotificationClient.NotifyBlockPresent(context.Background(), &amp;proto.NotifyBlockPresentRequest{
                        Host:     s.opts.Host,
                        BlockId:  blockInfo.ID,
                        Path:     blockInfo.Path,
                        Crc:      blockInfo.CRC,
                        Sequence: blockInfo.Sequence,
                        Length:   blockInfo.Length,
                })
                allErrors = append(allErrors, err)
        }</span>

        <span class="cov0" title="0">err = errors.Join(allErrors...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to report blocks: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *service) HealthCheck() error <span class="cov8" title="1">{
        blockInfos, err := s.GetBlocks()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get blocks: %w", err)
        }</span>

        <span class="cov8" title="1">var allErrors []error

        for _, blockInfo := range blockInfos </span><span class="cov8" title="1">{
                path := blockInfo.DataFilePath

                if _, err = os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        err = s.DeleteBlock(blockInfo.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                allErrors = append(allErrors, fmt.Errorf("failed to delete block info: %w", err))
                        }</span>
                }
        }

        <span class="cov8" title="1">err = errors.Join(allErrors...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to health check blocks: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *service) ValidateCRC() error <span class="cov8" title="1">{
        type record struct {
                crc    uint32
                length uint32
        }
        pathRecords := map[string]record{}

        files, err := os.ReadDir(s.opts.Dir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot read dir %s : %w", s.opts.Dir, err)
        }</span>

        <span class="cov8" title="1">for _, f := range files </span><span class="cov8" title="1">{
                if f.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">path := f.Name()
                _, err := f.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov8" title="1">{
                        err := os.Remove(path)
                        if err != nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">pathRecords[path] = record{
                        crc:    crc32.ChecksumIEEE(data),
                        length: uint32(len(data)),
                }</span>
        }

        <span class="cov8" title="1">blockInfos, err := s.GetBlocks()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get blocks: %w", err)
        }</span>

        <span class="cov8" title="1">var allErrors []error

        for _, blockInfo := range blockInfos </span><span class="cov8" title="1">{
                path := blockInfo.DataFilePath
                blockCRC := blockInfo.CRC
                blockLength := blockInfo.Length

                willDelete := false

                record, found := pathRecords[path]
                if found </span><span class="cov0" title="0">{
                        if record.crc != blockCRC || record.length != blockLength </span><span class="cov0" title="0">{
                                willDelete = true
                        }</span>
                } else<span class="cov8" title="1"> {
                        willDelete = true
                }</span>
                <span class="cov8" title="1">delete(pathRecords, path)

                if willDelete </span><span class="cov8" title="1">{
                        err = s.DeleteBlock(blockInfo.ID)
                        allErrors = append(allErrors, err)
                }</span>
        }

        <span class="cov8" title="1">for path := range pathRecords </span><span class="cov0" title="0">{
                err = os.Remove(path)
                allErrors = append(allErrors, err)
        }</span>

        <span class="cov8" title="1">err = errors.Join(allErrors...)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate crc: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package node

import (
        "context"
        "fmt"
        "github.com/cirglo.com/dfs/pkg/proto"
        "github.com/sirupsen/logrus"
)

type ServerOpts struct {
        Logger            *logrus.Logger
        BlockService      BlockService
        ConnectionFactory proto.ConnectionFactory
}

func (s ServerOpts) Validate() error <span class="cov8" title="1">{
        if s.Logger == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no logger provided")
        }</span>
        <span class="cov8" title="1">if s.BlockService == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no service provided")
        }</span>
        <span class="cov8" title="1">if s.ConnectionFactory == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no client connection factory provided")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type server struct {
        opts ServerOpts
        proto.UnimplementedNodeServer
}

var _ proto.NodeServer = &amp;server{}

func NewServer(opts ServerOpts) (proto.NodeServer, error) <span class="cov8" title="1">{
        err := opts.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid options: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;server{
                opts: opts,
        }, nil</span>
}

func (s *server) GetBlockInfos(ctx context.Context, _ *proto.GetBlockInfosRequest) (*proto.GetBlockInfosResponse, error) <span class="cov8" title="1">{
        bis, err := s.opts.BlockService.GetBlocks()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">blockInfos := []*proto.BlockInfo{}

        for _, bi := range bis </span><span class="cov8" title="1">{
                blockInfo := &amp;proto.BlockInfo{
                        BlockId:  bi.ID,
                        Crc:      bi.CRC,
                        Sequence: bi.Sequence,
                        Length:   bi.Length,
                }

                blockInfos = append(blockInfos, blockInfo)
        }</span>

        <span class="cov8" title="1">return &amp;proto.GetBlockInfosResponse{BlockInfos: blockInfos}, nil</span>
}

func (s *server) GetBlockInfo(ctx context.Context, request *proto.GetBlockInfoRequest) (*proto.GetBlockInfoResponse, error) <span class="cov8" title="1">{
        bis, err := s.opts.BlockService.GetBlocks()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, bi := range bis </span><span class="cov8" title="1">{
                if bi.ID == request.GetId() </span><span class="cov8" title="1">{
                        return &amp;proto.GetBlockInfoResponse{BlockInfo: &amp;proto.BlockInfo{
                                BlockId:  bi.ID,
                                Crc:      bi.CRC,
                                Sequence: bi.Sequence,
                                Length:   bi.Length,
                                Path:     bi.Path,
                        }}, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("block %s not found", request.GetId())</span>
}

func (s *server) GetBlock(ctx context.Context, request *proto.GetBlockRequest) (*proto.GetBlockResponse, error) <span class="cov8" title="1">{
        b, bi, err := s.opts.BlockService.ReadBlock(request.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;proto.GetBlockResponse{
                Data: b,
                BlockInfo: &amp;proto.BlockInfo{
                        BlockId:  bi.ID,
                        Crc:      bi.CRC,
                        Sequence: bi.Sequence,
                        Length:   bi.Length,
                        Path:     bi.Path,
                }}, nil</span>
}

func (s *server) WriteBlock(ctx context.Context, request *proto.WriteBlockRequest) (*proto.WriteBlockResponse, error) <span class="cov8" title="1">{
        err := s.opts.BlockService.WriteBlock(
                request.GetId(),
                request.GetPath(),
                request.GetSequence(),
                request.GetData())

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;proto.WriteBlockResponse{}, nil</span>
}

func (s *server) DeleteBlock(ctx context.Context, request *proto.DeleteBlockRequest) (*proto.DeleteBlockResponse, error) <span class="cov8" title="1">{
        err := s.opts.BlockService.DeleteBlock(request.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;proto.DeleteBlockResponse{}, nil</span>
}

func (s *server) CopyBlock(ctx context.Context, request *proto.CopyBlockRequest) (*proto.CopyBlockResponse, error) <span class="cov0" title="0">{
        data, blockInfo, err := s.opts.BlockService.ReadBlock(request.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read data for block id %s : %w", blockInfo.ID, err)
        }</span>

        <span class="cov0" title="0">conn, err := s.opts.ConnectionFactory.CreateConnection(request.GetDestination())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to destination node: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        client := proto.NewNodeClient(conn)
        _, err = client.WriteBlock(ctx, &amp;proto.WriteBlockRequest{
                Id:       blockInfo.ID,
                Path:     blockInfo.Path,
                Sequence: blockInfo.Sequence,
                Data:     data,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write data for block id %s : %w", blockInfo.ID, err)
        }</span>

        <span class="cov0" title="0">return &amp;proto.CopyBlockResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package proto

import (
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

type ConnectionFactory interface {
        CreateConnection(target string) (*grpc.ClientConn, error)
}

type insecureConnectionFactory struct {
}

var _ ConnectionFactory = &amp;insecureConnectionFactory{}

func (i insecureConnectionFactory) CreateConnection(target string) (*grpc.ClientConn, error) <span class="cov0" title="0">{
        return grpc.NewClient(target, grpc.WithTransportCredentials(insecure.NewCredentials()))
}</span>

func NewInsecureConnectionFactory() ConnectionFactory <span class="cov0" title="0">{
        return &amp;insecureConnectionFactory{}
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: names.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Permission struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Read          bool                   `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
        Write         bool                   `protobuf:"varint,2,opt,name=write,proto3" json:"write,omitempty"`
        Delete        bool                   `protobuf:"varint,3,opt,name=delete,proto3" json:"delete,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Permission) Reset() <span class="cov0" title="0">{
        *x = Permission{}
        mi := &amp;file_names_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Permission) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Permission) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Permission) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Permission.ProtoReflect.Descriptor instead.
func (*Permission) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Permission) GetRead() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Read
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Permission) GetWrite() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Write
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Permission) GetDelete() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Delete
        }</span>
        <span class="cov0" title="0">return false</span>
}

type Permissions struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Owner           string                 `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
        Group           string                 `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
        OwnerPermission *Permission            `protobuf:"bytes,3,opt,name=ownerPermission,proto3" json:"ownerPermission,omitempty"`
        GroupPermission *Permission            `protobuf:"bytes,4,opt,name=groupPermission,proto3" json:"groupPermission,omitempty"`
        OtherPermission *Permission            `protobuf:"bytes,5,opt,name=otherPermission,proto3" json:"otherPermission,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *Permissions) Reset() <span class="cov0" title="0">{
        *x = Permissions{}
        mi := &amp;file_names_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Permissions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Permissions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Permissions) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Permissions.ProtoReflect.Descriptor instead.
func (*Permissions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Permissions) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Permissions) GetGroup() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Group
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Permissions) GetOwnerPermission() *Permission <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OwnerPermission
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Permissions) GetGroupPermission() *Permission <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GroupPermission
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Permissions) GetOtherPermission() *Permission <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OtherPermission
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DirEntry struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
        IsDir         bool                   `protobuf:"varint,2,opt,name=isDir,proto3" json:"isDir,omitempty"`
        Permissions   *Permissions           `protobuf:"bytes,3,opt,name=permissions,proto3" json:"permissions,omitempty"`
        CreatedAt     int64                  `protobuf:"varint,4,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
        ModifiedAt    int64                  `protobuf:"varint,5,opt,name=modifiedAt,proto3" json:"modifiedAt,omitempty"`
        AccessedAt    int64                  `protobuf:"varint,6,opt,name=accessedAt,proto3" json:"accessedAt,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DirEntry) Reset() <span class="cov0" title="0">{
        *x = DirEntry{}
        mi := &amp;file_names_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DirEntry) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DirEntry) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DirEntry) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DirEntry.ProtoReflect.Descriptor instead.
func (*DirEntry) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DirEntry) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DirEntry) GetIsDir() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsDir
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *DirEntry) GetPermissions() *Permissions <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DirEntry) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DirEntry) GetModifiedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ModifiedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DirEntry) GetAccessedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type StatBlockInfo struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Host          string                 `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
        Port          uint32                 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
        BlockId       string                 `protobuf:"bytes,3,opt,name=blockId,proto3" json:"blockId,omitempty"`
        Crc           uint32                 `protobuf:"varint,5,opt,name=crc,proto3" json:"crc,omitempty"`
        Sequence      uint64                 `protobuf:"varint,6,opt,name=sequence,proto3" json:"sequence,omitempty"`
        Length        uint32                 `protobuf:"varint,7,opt,name=length,proto3" json:"length,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatBlockInfo) Reset() <span class="cov0" title="0">{
        *x = StatBlockInfo{}
        mi := &amp;file_names_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatBlockInfo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatBlockInfo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatBlockInfo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatBlockInfo.ProtoReflect.Descriptor instead.
func (*StatBlockInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{3}
}</span>

func (x *StatBlockInfo) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StatBlockInfo) GetPort() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatBlockInfo) GetBlockId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StatBlockInfo) GetCrc() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Crc
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatBlockInfo) GetSequence() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sequence
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatBlockInfo) GetLength() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Length
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type LoginRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        User           string                 `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        HashedPassword string                 `protobuf:"bytes,2,opt,name=hashedPassword,proto3" json:"hashedPassword,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        mi := &amp;file_names_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{4}
}</span>

func (x *LoginRequest) GetUser() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetHashedPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HashedPassword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          string                 `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        Token         string                 `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        mi := &amp;file_names_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{5}
}</span>

func (x *LoginResponse) GetUser() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LogoutRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogoutRequest) Reset() <span class="cov0" title="0">{
        *x = LogoutRequest{}
        mi := &amp;file_names_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{6}
}</span>

func (x *LogoutRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LogoutResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogoutResponse) Reset() <span class="cov0" title="0">{
        *x = LogoutResponse{}
        mi := &amp;file_names_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.
func (*LogoutResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{7}
}</span>

type CreateFileRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
        Permissions   *Permissions           `protobuf:"bytes,3,opt,name=permissions,proto3" json:"permissions,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateFileRequest) Reset() <span class="cov0" title="0">{
        *x = CreateFileRequest{}
        mi := &amp;file_names_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateFileRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateFileRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateFileRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateFileRequest.ProtoReflect.Descriptor instead.
func (*CreateFileRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{8}
}</span>

func (x *CreateFileRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateFileRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateFileRequest) GetPermissions() *Permissions <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateFileResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateFileResponse) Reset() <span class="cov0" title="0">{
        *x = CreateFileResponse{}
        mi := &amp;file_names_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateFileResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateFileResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateFileResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateFileResponse.ProtoReflect.Descriptor instead.
func (*CreateFileResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{9}
}</span>

type CreateDirRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
        Permissions   *Permissions           `protobuf:"bytes,3,opt,name=permissions,proto3" json:"permissions,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateDirRequest) Reset() <span class="cov0" title="0">{
        *x = CreateDirRequest{}
        mi := &amp;file_names_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateDirRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateDirRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateDirRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateDirRequest.ProtoReflect.Descriptor instead.
func (*CreateDirRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{10}
}</span>

func (x *CreateDirRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateDirRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateDirRequest) GetPermissions() *Permissions <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateDirResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateDirResponse) Reset() <span class="cov0" title="0">{
        *x = CreateDirResponse{}
        mi := &amp;file_names_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateDirResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateDirResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateDirResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateDirResponse.ProtoReflect.Descriptor instead.
func (*CreateDirResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{11}
}</span>

type DeleteFileRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteFileRequest{}
        mi := &amp;file_names_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteFileRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteFileRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteFileRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteFileRequest.ProtoReflect.Descriptor instead.
func (*DeleteFileRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{12}
}</span>

func (x *DeleteFileRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DeleteFileRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteFileResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteFileResponse{}
        mi := &amp;file_names_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteFileResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteFileResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteFileResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteFileResponse.ProtoReflect.Descriptor instead.
func (*DeleteFileResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{13}
}</span>

type DeleteDirRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteDirRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteDirRequest{}
        mi := &amp;file_names_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteDirRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteDirRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteDirRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteDirRequest.ProtoReflect.Descriptor instead.
func (*DeleteDirRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{14}
}</span>

func (x *DeleteDirRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DeleteDirRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteDirResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteDirResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteDirResponse{}
        mi := &amp;file_names_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteDirResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteDirResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteDirResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteDirResponse.ProtoReflect.Descriptor instead.
func (*DeleteDirResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{15}
}</span>

type ListRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListRequest) Reset() <span class="cov0" title="0">{
        *x = ListRequest{}
        mi := &amp;file_names_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListRequest.ProtoReflect.Descriptor instead.
func (*ListRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{16}
}</span>

func (x *ListRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
        Entries       []*DirEntry            `protobuf:"bytes,2,rep,name=entries,proto3" json:"entries,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListResponse) Reset() <span class="cov0" title="0">{
        *x = ListResponse{}
        mi := &amp;file_names_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListResponse.ProtoReflect.Descriptor instead.
func (*ListResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{17}
}</span>

func (x *ListResponse) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListResponse) GetEntries() []*DirEntry <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entries
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type StatRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatRequest) Reset() <span class="cov0" title="0">{
        *x = StatRequest{}
        mi := &amp;file_names_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatRequest.ProtoReflect.Descriptor instead.
func (*StatRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{18}
}</span>

func (x *StatRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StatRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StatResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
        Entry         *DirEntry              `protobuf:"bytes,2,opt,name=entry,proto3" json:"entry,omitempty"`
        BlockInfos    []*StatBlockInfo       `protobuf:"bytes,3,rep,name=blockInfos,proto3" json:"blockInfos,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatResponse) Reset() <span class="cov0" title="0">{
        *x = StatResponse{}
        mi := &amp;file_names_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_names_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatResponse.ProtoReflect.Descriptor instead.
func (*StatResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_names_proto_rawDescGZIP(), []int{19}
}</span>

func (x *StatResponse) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StatResponse) GetEntry() *DirEntry <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entry
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StatResponse) GetBlockInfos() []*StatBlockInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockInfos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_names_proto protoreflect.FileDescriptor

const file_names_proto_rawDesc = "" +
        "\n" +
        "\vnames.proto\x12\x04name\"N\n" +
        "\n" +
        "Permission\x12\x12\n" +
        "\x04read\x18\x01 \x01(\bR\x04read\x12\x14\n" +
        "\x05write\x18\x02 \x01(\bR\x05write\x12\x16\n" +
        "\x06delete\x18\x03 \x01(\bR\x06delete\"\xed\x01\n" +
        "\vPermissions\x12\x14\n" +
        "\x05owner\x18\x01 \x01(\tR\x05owner\x12\x14\n" +
        "\x05group\x18\x02 \x01(\tR\x05group\x12:\n" +
        "\x0fownerPermission\x18\x03 \x01(\v2\x10.name.PermissionR\x0fownerPermission\x12:\n" +
        "\x0fgroupPermission\x18\x04 \x01(\v2\x10.name.PermissionR\x0fgroupPermission\x12:\n" +
        "\x0fotherPermission\x18\x05 \x01(\v2\x10.name.PermissionR\x0fotherPermission\"\xc7\x01\n" +
        "\bDirEntry\x12\x12\n" +
        "\x04path\x18\x01 \x01(\tR\x04path\x12\x14\n" +
        "\x05isDir\x18\x02 \x01(\bR\x05isDir\x123\n" +
        "\vpermissions\x18\x03 \x01(\v2\x11.name.PermissionsR\vpermissions\x12\x1c\n" +
        "\tcreatedAt\x18\x04 \x01(\x03R\tcreatedAt\x12\x1e\n" +
        "\n" +
        "modifiedAt\x18\x05 \x01(\x03R\n" +
        "modifiedAt\x12\x1e\n" +
        "\n" +
        "accessedAt\x18\x06 \x01(\x03R\n" +
        "accessedAt\"\x97\x01\n" +
        "\rStatBlockInfo\x12\x12\n" +
        "\x04host\x18\x01 \x01(\tR\x04host\x12\x12\n" +
        "\x04port\x18\x02 \x01(\rR\x04port\x12\x18\n" +
        "\ablockId\x18\x03 \x01(\tR\ablockId\x12\x10\n" +
        "\x03crc\x18\x05 \x01(\rR\x03crc\x12\x1a\n" +
        "\bsequence\x18\x06 \x01(\x04R\bsequence\x12\x16\n" +
        "\x06length\x18\a \x01(\rR\x06length\"J\n" +
        "\fLoginRequest\x12\x12\n" +
        "\x04user\x18\x01 \x01(\tR\x04user\x12&amp;\n" +
        "\x0ehashedPassword\x18\x02 \x01(\tR\x0ehashedPassword\"9\n" +
        "\rLoginResponse\x12\x12\n" +
        "\x04user\x18\x01 \x01(\tR\x04user\x12\x14\n" +
        "\x05token\x18\x02 \x01(\tR\x05token\"%\n" +
        "\rLogoutRequest\x12\x14\n" +
        "\x05token\x18\x01 \x01(\tR\x05token\"\x10\n" +
        "\x0eLogoutResponse\"r\n" +
        "\x11CreateFileRequest\x12\x14\n" +
        "\x05token\x18\x01 \x01(\tR\x05token\x12\x12\n" +
        "\x04path\x18\x02 \x01(\tR\x04path\x123\n" +
        "\vpermissions\x18\x03 \x01(\v2\x11.name.PermissionsR\vpermissions\"\x14\n" +
        "\x12CreateFileResponse\"q\n" +
        "\x10CreateDirRequest\x12\x14\n" +
        "\x05token\x18\x01 \x01(\tR\x05token\x12\x12\n" +
        "\x04path\x18\x02 \x01(\tR\x04path\x123\n" +
        "\vpermissions\x18\x03 \x01(\v2\x11.name.PermissionsR\vpermissions\"\x13\n" +
        "\x11CreateDirResponse\"=\n" +
        "\x11DeleteFileRequest\x12\x14\n" +
        "\x05token\x18\x01 \x01(\tR\x05token\x12\x12\n" +
        "\x04path\x18\x02 \x01(\tR\x04path\"\x14\n" +
        "\x12DeleteFileResponse\"&lt;\n" +
        "\x10DeleteDirRequest\x12\x14\n" +
        "\x05token\x18\x01 \x01(\tR\x05token\x12\x12\n" +
        "\x04path\x18\x02 \x01(\tR\x04path\"\x13\n" +
        "\x11DeleteDirResponse\"7\n" +
        "\vListRequest\x12\x14\n" +
        "\x05token\x18\x01 \x01(\tR\x05token\x12\x12\n" +
        "\x04path\x18\x02 \x01(\tR\x04path\"L\n" +
        "\fListResponse\x12\x12\n" +
        "\x04path\x18\x01 \x01(\tR\x04path\x12(\n" +
        "\aentries\x18\x02 \x03(\v2\x0e.name.DirEntryR\aentries\"7\n" +
        "\vStatRequest\x12\x14\n" +
        "\x05token\x18\x01 \x01(\tR\x05token\x12\x12\n" +
        "\x04path\x18\x02 \x01(\tR\x04path\"}\n" +
        "\fStatResponse\x12\x12\n" +
        "\x04path\x18\x01 \x01(\tR\x04path\x12$\n" +
        "\x05entry\x18\x02 \x01(\v2\x0e.name.DirEntryR\x05entry\x123\n" +
        "\n" +
        "blockInfos\x18\x03 \x03(\v2\x13.name.StatBlockInfoR\n" +
        "blockInfos2\xc9\x03\n" +
        "\x04Name\x120\n" +
        "\x05Login\x12\x12.name.LoginRequest\x1a\x13.name.LoginResponse\x123\n" +
        "\x06Logout\x12\x13.name.LogoutRequest\x1a\x14.name.LogoutResponse\x12?\n" +
        "\n" +
        "CreateFile\x12\x17.name.CreateFileRequest\x1a\x18.name.CreateFileResponse\x12&lt;\n" +
        "\tCreateDir\x12\x16.name.CreateDirRequest\x1a\x17.name.CreateDirResponse\x12?\n" +
        "\n" +
        "DeleteFile\x12\x17.name.DeleteFileRequest\x1a\x18.name.DeleteFileResponse\x12&lt;\n" +
        "\tDeleteDir\x12\x16.name.DeleteDirRequest\x1a\x17.name.DeleteDirResponse\x12-\n" +
        "\x04List\x12\x11.name.ListRequest\x1a\x12.name.ListResponse\x12-\n" +
        "\x04Stat\x12\x11.name.StatRequest\x1a\x12.name.StatResponseB\n" +
        "Z\b./;protob\x06proto3"

var (
        file_names_proto_rawDescOnce sync.Once
        file_names_proto_rawDescData []byte
)

func file_names_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_names_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_names_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_names_proto_rawDesc), len(file_names_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_names_proto_rawDescData</span>
}

var file_names_proto_msgTypes = make([]protoimpl.MessageInfo, 20)
var file_names_proto_goTypes = []any{
        (*Permission)(nil),         // 0: name.Permission
        (*Permissions)(nil),        // 1: name.Permissions
        (*DirEntry)(nil),           // 2: name.DirEntry
        (*StatBlockInfo)(nil),      // 3: name.StatBlockInfo
        (*LoginRequest)(nil),       // 4: name.LoginRequest
        (*LoginResponse)(nil),      // 5: name.LoginResponse
        (*LogoutRequest)(nil),      // 6: name.LogoutRequest
        (*LogoutResponse)(nil),     // 7: name.LogoutResponse
        (*CreateFileRequest)(nil),  // 8: name.CreateFileRequest
        (*CreateFileResponse)(nil), // 9: name.CreateFileResponse
        (*CreateDirRequest)(nil),   // 10: name.CreateDirRequest
        (*CreateDirResponse)(nil),  // 11: name.CreateDirResponse
        (*DeleteFileRequest)(nil),  // 12: name.DeleteFileRequest
        (*DeleteFileResponse)(nil), // 13: name.DeleteFileResponse
        (*DeleteDirRequest)(nil),   // 14: name.DeleteDirRequest
        (*DeleteDirResponse)(nil),  // 15: name.DeleteDirResponse
        (*ListRequest)(nil),        // 16: name.ListRequest
        (*ListResponse)(nil),       // 17: name.ListResponse
        (*StatRequest)(nil),        // 18: name.StatRequest
        (*StatResponse)(nil),       // 19: name.StatResponse
}
var file_names_proto_depIdxs = []int32{
        0,  // 0: name.Permissions.ownerPermission:type_name -&gt; name.Permission
        0,  // 1: name.Permissions.groupPermission:type_name -&gt; name.Permission
        0,  // 2: name.Permissions.otherPermission:type_name -&gt; name.Permission
        1,  // 3: name.DirEntry.permissions:type_name -&gt; name.Permissions
        1,  // 4: name.CreateFileRequest.permissions:type_name -&gt; name.Permissions
        1,  // 5: name.CreateDirRequest.permissions:type_name -&gt; name.Permissions
        2,  // 6: name.ListResponse.entries:type_name -&gt; name.DirEntry
        2,  // 7: name.StatResponse.entry:type_name -&gt; name.DirEntry
        3,  // 8: name.StatResponse.blockInfos:type_name -&gt; name.StatBlockInfo
        4,  // 9: name.Name.Login:input_type -&gt; name.LoginRequest
        6,  // 10: name.Name.Logout:input_type -&gt; name.LogoutRequest
        8,  // 11: name.Name.CreateFile:input_type -&gt; name.CreateFileRequest
        10, // 12: name.Name.CreateDir:input_type -&gt; name.CreateDirRequest
        12, // 13: name.Name.DeleteFile:input_type -&gt; name.DeleteFileRequest
        14, // 14: name.Name.DeleteDir:input_type -&gt; name.DeleteDirRequest
        16, // 15: name.Name.List:input_type -&gt; name.ListRequest
        18, // 16: name.Name.Stat:input_type -&gt; name.StatRequest
        5,  // 17: name.Name.Login:output_type -&gt; name.LoginResponse
        7,  // 18: name.Name.Logout:output_type -&gt; name.LogoutResponse
        9,  // 19: name.Name.CreateFile:output_type -&gt; name.CreateFileResponse
        11, // 20: name.Name.CreateDir:output_type -&gt; name.CreateDirResponse
        13, // 21: name.Name.DeleteFile:output_type -&gt; name.DeleteFileResponse
        15, // 22: name.Name.DeleteDir:output_type -&gt; name.DeleteDirResponse
        17, // 23: name.Name.List:output_type -&gt; name.ListResponse
        19, // 24: name.Name.Stat:output_type -&gt; name.StatResponse
        17, // [17:25] is the sub-list for method output_type
        9,  // [9:17] is the sub-list for method input_type
        9,  // [9:9] is the sub-list for extension type_name
        9,  // [9:9] is the sub-list for extension extendee
        0,  // [0:9] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_names_proto_init() }</span>
func file_names_proto_init() <span class="cov0" title="0">{
        if File_names_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_names_proto_rawDesc), len(file_names_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   20,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_names_proto_goTypes,
                DependencyIndexes: file_names_proto_depIdxs,
                MessageInfos:      file_names_proto_msgTypes,
        }.Build()
        File_names_proto = out.File
        file_names_proto_goTypes = nil
        file_names_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: names.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Name_Login_FullMethodName      = "/name.Name/Login"
        Name_Logout_FullMethodName     = "/name.Name/Logout"
        Name_CreateFile_FullMethodName = "/name.Name/CreateFile"
        Name_CreateDir_FullMethodName  = "/name.Name/CreateDir"
        Name_DeleteFile_FullMethodName = "/name.Name/DeleteFile"
        Name_DeleteDir_FullMethodName  = "/name.Name/DeleteDir"
        Name_List_FullMethodName       = "/name.Name/List"
        Name_Stat_FullMethodName       = "/name.Name/Stat"
)

// NameClient is the client API for Name service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NameClient interface {
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
        Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
        CreateFile(ctx context.Context, in *CreateFileRequest, opts ...grpc.CallOption) (*CreateFileResponse, error)
        CreateDir(ctx context.Context, in *CreateDirRequest, opts ...grpc.CallOption) (*CreateDirResponse, error)
        DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error)
        DeleteDir(ctx context.Context, in *DeleteDirRequest, opts ...grpc.CallOption) (*DeleteDirResponse, error)
        List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
        Stat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatResponse, error)
}

type nameClient struct {
        cc grpc.ClientConnInterface
}

func NewNameClient(cc grpc.ClientConnInterface) NameClient <span class="cov0" title="0">{
        return &amp;nameClient{cc}
}</span>

func (c *nameClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, Name_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nameClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LogoutResponse)
        err := c.cc.Invoke(ctx, Name_Logout_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nameClient) CreateFile(ctx context.Context, in *CreateFileRequest, opts ...grpc.CallOption) (*CreateFileResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateFileResponse)
        err := c.cc.Invoke(ctx, Name_CreateFile_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nameClient) CreateDir(ctx context.Context, in *CreateDirRequest, opts ...grpc.CallOption) (*CreateDirResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateDirResponse)
        err := c.cc.Invoke(ctx, Name_CreateDir_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nameClient) DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteFileResponse)
        err := c.cc.Invoke(ctx, Name_DeleteFile_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nameClient) DeleteDir(ctx context.Context, in *DeleteDirRequest, opts ...grpc.CallOption) (*DeleteDirResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteDirResponse)
        err := c.cc.Invoke(ctx, Name_DeleteDir_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nameClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListResponse)
        err := c.cc.Invoke(ctx, Name_List_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nameClient) Stat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatResponse)
        err := c.cc.Invoke(ctx, Name_Stat_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// NameServer is the server API for Name service.
// All implementations must embed UnimplementedNameServer
// for forward compatibility.
type NameServer interface {
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
        CreateFile(context.Context, *CreateFileRequest) (*CreateFileResponse, error)
        CreateDir(context.Context, *CreateDirRequest) (*CreateDirResponse, error)
        DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error)
        DeleteDir(context.Context, *DeleteDirRequest) (*DeleteDirResponse, error)
        List(context.Context, *ListRequest) (*ListResponse, error)
        Stat(context.Context, *StatRequest) (*StatResponse, error)
        mustEmbedUnimplementedNameServer()
}

// UnimplementedNameServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNameServer struct{}

func (UnimplementedNameServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedNameServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}</span>
func (UnimplementedNameServer) CreateFile(context.Context, *CreateFileRequest) (*CreateFileResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateFile not implemented")
}</span>
func (UnimplementedNameServer) CreateDir(context.Context, *CreateDirRequest) (*CreateDirResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateDir not implemented")
}</span>
func (UnimplementedNameServer) DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteFile not implemented")
}</span>
func (UnimplementedNameServer) DeleteDir(context.Context, *DeleteDirRequest) (*DeleteDirResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteDir not implemented")
}</span>
func (UnimplementedNameServer) List(context.Context, *ListRequest) (*ListResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}</span>
func (UnimplementedNameServer) Stat(context.Context, *StatRequest) (*StatResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Stat not implemented")
}</span>
func (UnimplementedNameServer) mustEmbedUnimplementedNameServer() {<span class="cov0" title="0">}</span>
func (UnimplementedNameServer) testEmbeddedByValue()              {<span class="cov0" title="0">}</span>

// UnsafeNameServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NameServer will
// result in compilation errors.
type UnsafeNameServer interface {
        mustEmbedUnimplementedNameServer()
}

func RegisterNameServer(s grpc.ServiceRegistrar, srv NameServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedNameServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Name_ServiceDesc, srv)</span>
}

func _Name_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NameServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Name_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NameServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Name_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LogoutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NameServer).Logout(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Name_Logout_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NameServer).Logout(ctx, req.(*LogoutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Name_CreateFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateFileRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NameServer).CreateFile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Name_CreateFile_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NameServer).CreateFile(ctx, req.(*CreateFileRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Name_CreateDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateDirRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NameServer).CreateDir(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Name_CreateDir_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NameServer).CreateDir(ctx, req.(*CreateDirRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Name_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteFileRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NameServer).DeleteFile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Name_DeleteFile_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NameServer).DeleteFile(ctx, req.(*DeleteFileRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Name_DeleteDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteDirRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NameServer).DeleteDir(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Name_DeleteDir_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NameServer).DeleteDir(ctx, req.(*DeleteDirRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Name_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NameServer).List(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Name_List_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NameServer).List(ctx, req.(*ListRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Name_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StatRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NameServer).Stat(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Name_Stat_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NameServer).Stat(ctx, req.(*StatRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Name_ServiceDesc is the grpc.ServiceDesc for Name service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Name_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "name.Name",
        HandlerType: (*NameServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Login",
                        Handler:    _Name_Login_Handler,
                },
                {
                        MethodName: "Logout",
                        Handler:    _Name_Logout_Handler,
                },
                {
                        MethodName: "CreateFile",
                        Handler:    _Name_CreateFile_Handler,
                },
                {
                        MethodName: "CreateDir",
                        Handler:    _Name_CreateDir_Handler,
                },
                {
                        MethodName: "DeleteFile",
                        Handler:    _Name_DeleteFile_Handler,
                },
                {
                        MethodName: "DeleteDir",
                        Handler:    _Name_DeleteDir_Handler,
                },
                {
                        MethodName: "List",
                        Handler:    _Name_List_Handler,
                },
                {
                        MethodName: "Stat",
                        Handler:    _Name_Stat_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "names.proto",
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: nodes.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type BlockInfo struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        BlockId       string                 `protobuf:"bytes,1,opt,name=blockId,proto3" json:"blockId,omitempty"`
        Crc           uint32                 `protobuf:"varint,2,opt,name=crc,proto3" json:"crc,omitempty"`
        Sequence      uint64                 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
        Length        uint32                 `protobuf:"varint,4,opt,name=length,proto3" json:"length,omitempty"`
        Path          string                 `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BlockInfo) Reset() <span class="cov0" title="0">{
        *x = BlockInfo{}
        mi := &amp;file_nodes_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BlockInfo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BlockInfo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BlockInfo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BlockInfo.ProtoReflect.Descriptor instead.
func (*BlockInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{0}
}</span>

func (x *BlockInfo) GetBlockId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BlockInfo) GetCrc() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Crc
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BlockInfo) GetSequence() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sequence
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BlockInfo) GetLength() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Length
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BlockInfo) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Define a User message
type GetBlockInfosRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetBlockInfosRequest) Reset() <span class="cov0" title="0">{
        *x = GetBlockInfosRequest{}
        mi := &amp;file_nodes_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBlockInfosRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBlockInfosRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBlockInfosRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBlockInfosRequest.ProtoReflect.Descriptor instead.
func (*GetBlockInfosRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{1}
}</span>

type GetBlockInfosResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        BlockInfos    []*BlockInfo           `protobuf:"bytes,1,rep,name=blockInfos,proto3" json:"blockInfos,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetBlockInfosResponse) Reset() <span class="cov0" title="0">{
        *x = GetBlockInfosResponse{}
        mi := &amp;file_nodes_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBlockInfosResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBlockInfosResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBlockInfosResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBlockInfosResponse.ProtoReflect.Descriptor instead.
func (*GetBlockInfosResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetBlockInfosResponse) GetBlockInfos() []*BlockInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockInfos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBlockInfoRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetBlockInfoRequest) Reset() <span class="cov0" title="0">{
        *x = GetBlockInfoRequest{}
        mi := &amp;file_nodes_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBlockInfoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBlockInfoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBlockInfoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBlockInfoRequest.ProtoReflect.Descriptor instead.
func (*GetBlockInfoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetBlockInfoRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBlockInfoResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        BlockInfo     *BlockInfo             `protobuf:"bytes,1,opt,name=blockInfo,proto3" json:"blockInfo,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetBlockInfoResponse) Reset() <span class="cov0" title="0">{
        *x = GetBlockInfoResponse{}
        mi := &amp;file_nodes_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBlockInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBlockInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBlockInfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBlockInfoResponse.ProtoReflect.Descriptor instead.
func (*GetBlockInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{4}
}</span>

func (x *GetBlockInfoResponse) GetBlockInfo() *BlockInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockInfo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBlockRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetBlockRequest) Reset() <span class="cov0" title="0">{
        *x = GetBlockRequest{}
        mi := &amp;file_nodes_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBlockRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBlockRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBlockRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBlockRequest.ProtoReflect.Descriptor instead.
func (*GetBlockRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetBlockRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBlockResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        BlockInfo     *BlockInfo             `protobuf:"bytes,1,opt,name=blockInfo,proto3" json:"blockInfo,omitempty"`
        Data          []byte                 `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetBlockResponse) Reset() <span class="cov0" title="0">{
        *x = GetBlockResponse{}
        mi := &amp;file_nodes_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBlockResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBlockResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBlockResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBlockResponse.ProtoReflect.Descriptor instead.
func (*GetBlockResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetBlockResponse) GetBlockInfo() *BlockInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockInfo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetBlockResponse) GetData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type WriteBlockRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
        Sequence      uint64                 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
        Data          []byte                 `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *WriteBlockRequest) Reset() <span class="cov0" title="0">{
        *x = WriteBlockRequest{}
        mi := &amp;file_nodes_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *WriteBlockRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WriteBlockRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WriteBlockRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WriteBlockRequest.ProtoReflect.Descriptor instead.
func (*WriteBlockRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{7}
}</span>

func (x *WriteBlockRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *WriteBlockRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *WriteBlockRequest) GetSequence() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sequence
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *WriteBlockRequest) GetData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type WriteBlockResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *WriteBlockResponse) Reset() <span class="cov0" title="0">{
        *x = WriteBlockResponse{}
        mi := &amp;file_nodes_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *WriteBlockResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WriteBlockResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WriteBlockResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WriteBlockResponse.ProtoReflect.Descriptor instead.
func (*WriteBlockResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{8}
}</span>

type DeleteBlockRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteBlockRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteBlockRequest{}
        mi := &amp;file_nodes_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteBlockRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteBlockRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteBlockRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteBlockRequest.ProtoReflect.Descriptor instead.
func (*DeleteBlockRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{9}
}</span>

func (x *DeleteBlockRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteBlockResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteBlockResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteBlockResponse{}
        mi := &amp;file_nodes_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteBlockResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteBlockResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteBlockResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteBlockResponse.ProtoReflect.Descriptor instead.
func (*DeleteBlockResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{10}
}</span>

type CopyBlockRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Destination   string                 `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CopyBlockRequest) Reset() <span class="cov0" title="0">{
        *x = CopyBlockRequest{}
        mi := &amp;file_nodes_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CopyBlockRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CopyBlockRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CopyBlockRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CopyBlockRequest.ProtoReflect.Descriptor instead.
func (*CopyBlockRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{11}
}</span>

func (x *CopyBlockRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CopyBlockRequest) GetDestination() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CopyBlockResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CopyBlockResponse) Reset() <span class="cov0" title="0">{
        *x = CopyBlockResponse{}
        mi := &amp;file_nodes_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CopyBlockResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CopyBlockResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CopyBlockResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_nodes_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CopyBlockResponse.ProtoReflect.Descriptor instead.
func (*CopyBlockResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_nodes_proto_rawDescGZIP(), []int{12}
}</span>

var File_nodes_proto protoreflect.FileDescriptor

const file_nodes_proto_rawDesc = "" +
        "\n" +
        "\vnodes.proto\x12\x04node\"\x7f\n" +
        "\tBlockInfo\x12\x18\n" +
        "\ablockId\x18\x01 \x01(\tR\ablockId\x12\x10\n" +
        "\x03crc\x18\x02 \x01(\rR\x03crc\x12\x1a\n" +
        "\bsequence\x18\x03 \x01(\x04R\bsequence\x12\x16\n" +
        "\x06length\x18\x04 \x01(\rR\x06length\x12\x12\n" +
        "\x04path\x18\x05 \x01(\tR\x04path\"\x16\n" +
        "\x14GetBlockInfosRequest\"H\n" +
        "\x15GetBlockInfosResponse\x12/\n" +
        "\n" +
        "blockInfos\x18\x01 \x03(\v2\x0f.node.BlockInfoR\n" +
        "blockInfos\"%\n" +
        "\x13GetBlockInfoRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"E\n" +
        "\x14GetBlockInfoResponse\x12-\n" +
        "\tblockInfo\x18\x01 \x01(\v2\x0f.node.BlockInfoR\tblockInfo\"!\n" +
        "\x0fGetBlockRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"U\n" +
        "\x10GetBlockResponse\x12-\n" +
        "\tblockInfo\x18\x01 \x01(\v2\x0f.node.BlockInfoR\tblockInfo\x12\x12\n" +
        "\x04data\x18\x02 \x01(\fR\x04data\"g\n" +
        "\x11WriteBlockRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04path\x18\x02 \x01(\tR\x04path\x12\x1a\n" +
        "\bsequence\x18\x03 \x01(\x04R\bsequence\x12\x12\n" +
        "\x04data\x18\x04 \x01(\fR\x04data\"\x14\n" +
        "\x12WriteBlockResponse\"$\n" +
        "\x12DeleteBlockRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"\x15\n" +
        "\x13DeleteBlockResponse\"D\n" +
        "\x10CopyBlockRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12 \n" +
        "\vdestination\x18\x02 \x01(\tR\vdestination\"\x13\n" +
        "\x11CopyBlockResponse2\x95\x03\n" +
        "\x04Node\x12H\n" +
        "\rGetBlockInfos\x12\x1a.node.GetBlockInfosRequest\x1a\x1b.node.GetBlockInfosResponse\x12E\n" +
        "\fGetBlockInfo\x12\x19.node.GetBlockInfoRequest\x1a\x1a.node.GetBlockInfoResponse\x129\n" +
        "\bGetBlock\x12\x15.node.GetBlockRequest\x1a\x16.node.GetBlockResponse\x12?\n" +
        "\n" +
        "WriteBlock\x12\x17.node.WriteBlockRequest\x1a\x18.node.WriteBlockResponse\x12B\n" +
        "\vDeleteBlock\x12\x18.node.DeleteBlockRequest\x1a\x19.node.DeleteBlockResponse\x12&lt;\n" +
        "\tCopyBlock\x12\x16.node.CopyBlockRequest\x1a\x17.node.CopyBlockResponseB\n" +
        "Z\b./;protob\x06proto3"

var (
        file_nodes_proto_rawDescOnce sync.Once
        file_nodes_proto_rawDescData []byte
)

func file_nodes_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_nodes_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_nodes_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_nodes_proto_rawDesc), len(file_nodes_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_nodes_proto_rawDescData</span>
}

var file_nodes_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_nodes_proto_goTypes = []any{
        (*BlockInfo)(nil),             // 0: node.BlockInfo
        (*GetBlockInfosRequest)(nil),  // 1: node.GetBlockInfosRequest
        (*GetBlockInfosResponse)(nil), // 2: node.GetBlockInfosResponse
        (*GetBlockInfoRequest)(nil),   // 3: node.GetBlockInfoRequest
        (*GetBlockInfoResponse)(nil),  // 4: node.GetBlockInfoResponse
        (*GetBlockRequest)(nil),       // 5: node.GetBlockRequest
        (*GetBlockResponse)(nil),      // 6: node.GetBlockResponse
        (*WriteBlockRequest)(nil),     // 7: node.WriteBlockRequest
        (*WriteBlockResponse)(nil),    // 8: node.WriteBlockResponse
        (*DeleteBlockRequest)(nil),    // 9: node.DeleteBlockRequest
        (*DeleteBlockResponse)(nil),   // 10: node.DeleteBlockResponse
        (*CopyBlockRequest)(nil),      // 11: node.CopyBlockRequest
        (*CopyBlockResponse)(nil),     // 12: node.CopyBlockResponse
}
var file_nodes_proto_depIdxs = []int32{
        0,  // 0: node.GetBlockInfosResponse.blockInfos:type_name -&gt; node.BlockInfo
        0,  // 1: node.GetBlockInfoResponse.blockInfo:type_name -&gt; node.BlockInfo
        0,  // 2: node.GetBlockResponse.blockInfo:type_name -&gt; node.BlockInfo
        1,  // 3: node.Node.GetBlockInfos:input_type -&gt; node.GetBlockInfosRequest
        3,  // 4: node.Node.GetBlockInfo:input_type -&gt; node.GetBlockInfoRequest
        5,  // 5: node.Node.GetBlock:input_type -&gt; node.GetBlockRequest
        7,  // 6: node.Node.WriteBlock:input_type -&gt; node.WriteBlockRequest
        9,  // 7: node.Node.DeleteBlock:input_type -&gt; node.DeleteBlockRequest
        11, // 8: node.Node.CopyBlock:input_type -&gt; node.CopyBlockRequest
        2,  // 9: node.Node.GetBlockInfos:output_type -&gt; node.GetBlockInfosResponse
        4,  // 10: node.Node.GetBlockInfo:output_type -&gt; node.GetBlockInfoResponse
        6,  // 11: node.Node.GetBlock:output_type -&gt; node.GetBlockResponse
        8,  // 12: node.Node.WriteBlock:output_type -&gt; node.WriteBlockResponse
        10, // 13: node.Node.DeleteBlock:output_type -&gt; node.DeleteBlockResponse
        12, // 14: node.Node.CopyBlock:output_type -&gt; node.CopyBlockResponse
        9,  // [9:15] is the sub-list for method output_type
        3,  // [3:9] is the sub-list for method input_type
        3,  // [3:3] is the sub-list for extension type_name
        3,  // [3:3] is the sub-list for extension extendee
        0,  // [0:3] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_nodes_proto_init() }</span>
func file_nodes_proto_init() <span class="cov0" title="0">{
        if File_nodes_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_nodes_proto_rawDesc), len(file_nodes_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   13,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_nodes_proto_goTypes,
                DependencyIndexes: file_nodes_proto_depIdxs,
                MessageInfos:      file_nodes_proto_msgTypes,
        }.Build()
        File_nodes_proto = out.File
        file_nodes_proto_goTypes = nil
        file_nodes_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: nodes.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Node_GetBlockInfos_FullMethodName = "/node.Node/GetBlockInfos"
        Node_GetBlockInfo_FullMethodName  = "/node.Node/GetBlockInfo"
        Node_GetBlock_FullMethodName      = "/node.Node/GetBlock"
        Node_WriteBlock_FullMethodName    = "/node.Node/WriteBlock"
        Node_DeleteBlock_FullMethodName   = "/node.Node/DeleteBlock"
        Node_CopyBlock_FullMethodName     = "/node.Node/CopyBlock"
)

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeClient interface {
        GetBlockInfos(ctx context.Context, in *GetBlockInfosRequest, opts ...grpc.CallOption) (*GetBlockInfosResponse, error)
        GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error)
        GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error)
        WriteBlock(ctx context.Context, in *WriteBlockRequest, opts ...grpc.CallOption) (*WriteBlockResponse, error)
        DeleteBlock(ctx context.Context, in *DeleteBlockRequest, opts ...grpc.CallOption) (*DeleteBlockResponse, error)
        CopyBlock(ctx context.Context, in *CopyBlockRequest, opts ...grpc.CallOption) (*CopyBlockResponse, error)
}

type nodeClient struct {
        cc grpc.ClientConnInterface
}

func NewNodeClient(cc grpc.ClientConnInterface) NodeClient <span class="cov0" title="0">{
        return &amp;nodeClient{cc}
}</span>

func (c *nodeClient) GetBlockInfos(ctx context.Context, in *GetBlockInfosRequest, opts ...grpc.CallOption) (*GetBlockInfosResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetBlockInfosResponse)
        err := c.cc.Invoke(ctx, Node_GetBlockInfos_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nodeClient) GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetBlockInfoResponse)
        err := c.cc.Invoke(ctx, Node_GetBlockInfo_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nodeClient) GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetBlockResponse)
        err := c.cc.Invoke(ctx, Node_GetBlock_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nodeClient) WriteBlock(ctx context.Context, in *WriteBlockRequest, opts ...grpc.CallOption) (*WriteBlockResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(WriteBlockResponse)
        err := c.cc.Invoke(ctx, Node_WriteBlock_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nodeClient) DeleteBlock(ctx context.Context, in *DeleteBlockRequest, opts ...grpc.CallOption) (*DeleteBlockResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteBlockResponse)
        err := c.cc.Invoke(ctx, Node_DeleteBlock_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *nodeClient) CopyBlock(ctx context.Context, in *CopyBlockRequest, opts ...grpc.CallOption) (*CopyBlockResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CopyBlockResponse)
        err := c.cc.Invoke(ctx, Node_CopyBlock_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// NodeServer is the server API for Node service.
// All implementations must embed UnimplementedNodeServer
// for forward compatibility.
type NodeServer interface {
        GetBlockInfos(context.Context, *GetBlockInfosRequest) (*GetBlockInfosResponse, error)
        GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoResponse, error)
        GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error)
        WriteBlock(context.Context, *WriteBlockRequest) (*WriteBlockResponse, error)
        DeleteBlock(context.Context, *DeleteBlockRequest) (*DeleteBlockResponse, error)
        CopyBlock(context.Context, *CopyBlockRequest) (*CopyBlockResponse, error)
        mustEmbedUnimplementedNodeServer()
}

// UnimplementedNodeServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodeServer struct{}

func (UnimplementedNodeServer) GetBlockInfos(context.Context, *GetBlockInfosRequest) (*GetBlockInfosResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfos not implemented")
}</span>
func (UnimplementedNodeServer) GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfo not implemented")
}</span>
func (UnimplementedNodeServer) GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}</span>
func (UnimplementedNodeServer) WriteBlock(context.Context, *WriteBlockRequest) (*WriteBlockResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method WriteBlock not implemented")
}</span>
func (UnimplementedNodeServer) DeleteBlock(context.Context, *DeleteBlockRequest) (*DeleteBlockResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteBlock not implemented")
}</span>
func (UnimplementedNodeServer) CopyBlock(context.Context, *CopyBlockRequest) (*CopyBlockResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CopyBlock not implemented")
}</span>
func (UnimplementedNodeServer) mustEmbedUnimplementedNodeServer() {<span class="cov0" title="0">}</span>
func (UnimplementedNodeServer) testEmbeddedByValue()              {<span class="cov0" title="0">}</span>

// UnsafeNodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServer will
// result in compilation errors.
type UnsafeNodeServer interface {
        mustEmbedUnimplementedNodeServer()
}

func RegisterNodeServer(s grpc.ServiceRegistrar, srv NodeServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedNodeServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Node_ServiceDesc, srv)</span>
}

func _Node_GetBlockInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetBlockInfosRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NodeServer).GetBlockInfos(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Node_GetBlockInfos_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NodeServer).GetBlockInfos(ctx, req.(*GetBlockInfosRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Node_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetBlockInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NodeServer).GetBlockInfo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Node_GetBlockInfo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NodeServer).GetBlockInfo(ctx, req.(*GetBlockInfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Node_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetBlockRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NodeServer).GetBlock(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Node_GetBlock_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NodeServer).GetBlock(ctx, req.(*GetBlockRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Node_WriteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(WriteBlockRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NodeServer).WriteBlock(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Node_WriteBlock_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NodeServer).WriteBlock(ctx, req.(*WriteBlockRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Node_DeleteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteBlockRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NodeServer).DeleteBlock(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Node_DeleteBlock_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NodeServer).DeleteBlock(ctx, req.(*DeleteBlockRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Node_CopyBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CopyBlockRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NodeServer).CopyBlock(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Node_CopyBlock_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NodeServer).CopyBlock(ctx, req.(*CopyBlockRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Node_ServiceDesc is the grpc.ServiceDesc for Node service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Node_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "node.Node",
        HandlerType: (*NodeServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetBlockInfos",
                        Handler:    _Node_GetBlockInfos_Handler,
                },
                {
                        MethodName: "GetBlockInfo",
                        Handler:    _Node_GetBlockInfo_Handler,
                },
                {
                        MethodName: "GetBlock",
                        Handler:    _Node_GetBlock_Handler,
                },
                {
                        MethodName: "WriteBlock",
                        Handler:    _Node_WriteBlock_Handler,
                },
                {
                        MethodName: "DeleteBlock",
                        Handler:    _Node_DeleteBlock_Handler,
                },
                {
                        MethodName: "CopyBlock",
                        Handler:    _Node_CopyBlock_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "nodes.proto",
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: notifications.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type NotifyBlockPresentRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Host          string                 `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
        BlockId       string                 `protobuf:"bytes,2,opt,name=blockId,proto3" json:"blockId,omitempty"`
        Path          string                 `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
        Crc           uint32                 `protobuf:"varint,4,opt,name=crc,proto3" json:"crc,omitempty"`
        Sequence      uint64                 `protobuf:"varint,5,opt,name=sequence,proto3" json:"sequence,omitempty"`
        Length        uint32                 `protobuf:"varint,6,opt,name=length,proto3" json:"length,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *NotifyBlockPresentRequest) Reset() <span class="cov0" title="0">{
        *x = NotifyBlockPresentRequest{}
        mi := &amp;file_notifications_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NotifyBlockPresentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NotifyBlockPresentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NotifyBlockPresentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notifications_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NotifyBlockPresentRequest.ProtoReflect.Descriptor instead.
func (*NotifyBlockPresentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notifications_proto_rawDescGZIP(), []int{0}
}</span>

func (x *NotifyBlockPresentRequest) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NotifyBlockPresentRequest) GetBlockId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NotifyBlockPresentRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NotifyBlockPresentRequest) GetCrc() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Crc
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NotifyBlockPresentRequest) GetSequence() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sequence
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NotifyBlockPresentRequest) GetLength() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Length
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type NotifyBlockPresentResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *NotifyBlockPresentResponse) Reset() <span class="cov0" title="0">{
        *x = NotifyBlockPresentResponse{}
        mi := &amp;file_notifications_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NotifyBlockPresentResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NotifyBlockPresentResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NotifyBlockPresentResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notifications_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NotifyBlockPresentResponse.ProtoReflect.Descriptor instead.
func (*NotifyBlockPresentResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notifications_proto_rawDescGZIP(), []int{1}
}</span>

type NotifyBlockAddedRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Host          string                 `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
        BlockId       string                 `protobuf:"bytes,2,opt,name=blockId,proto3" json:"blockId,omitempty"`
        Path          string                 `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
        Crc           uint32                 `protobuf:"varint,4,opt,name=crc,proto3" json:"crc,omitempty"`
        Sequence      uint64                 `protobuf:"varint,5,opt,name=sequence,proto3" json:"sequence,omitempty"`
        Length        uint32                 `protobuf:"varint,6,opt,name=length,proto3" json:"length,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *NotifyBlockAddedRequest) Reset() <span class="cov0" title="0">{
        *x = NotifyBlockAddedRequest{}
        mi := &amp;file_notifications_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NotifyBlockAddedRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NotifyBlockAddedRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NotifyBlockAddedRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notifications_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NotifyBlockAddedRequest.ProtoReflect.Descriptor instead.
func (*NotifyBlockAddedRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notifications_proto_rawDescGZIP(), []int{2}
}</span>

func (x *NotifyBlockAddedRequest) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NotifyBlockAddedRequest) GetBlockId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NotifyBlockAddedRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NotifyBlockAddedRequest) GetCrc() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Crc
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NotifyBlockAddedRequest) GetSequence() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sequence
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NotifyBlockAddedRequest) GetLength() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Length
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type NotifyBlockAddedResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *NotifyBlockAddedResponse) Reset() <span class="cov0" title="0">{
        *x = NotifyBlockAddedResponse{}
        mi := &amp;file_notifications_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NotifyBlockAddedResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NotifyBlockAddedResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NotifyBlockAddedResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notifications_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NotifyBlockAddedResponse.ProtoReflect.Descriptor instead.
func (*NotifyBlockAddedResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notifications_proto_rawDescGZIP(), []int{3}
}</span>

type NotifyBlockRemovedRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Host          string                 `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
        BlockId       string                 `protobuf:"bytes,2,opt,name=blockId,proto3" json:"blockId,omitempty"`
        Path          string                 `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *NotifyBlockRemovedRequest) Reset() <span class="cov0" title="0">{
        *x = NotifyBlockRemovedRequest{}
        mi := &amp;file_notifications_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NotifyBlockRemovedRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NotifyBlockRemovedRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NotifyBlockRemovedRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notifications_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NotifyBlockRemovedRequest.ProtoReflect.Descriptor instead.
func (*NotifyBlockRemovedRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notifications_proto_rawDescGZIP(), []int{4}
}</span>

func (x *NotifyBlockRemovedRequest) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NotifyBlockRemovedRequest) GetBlockId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NotifyBlockRemovedRequest) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type NotifyBlockRemovedResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *NotifyBlockRemovedResponse) Reset() <span class="cov0" title="0">{
        *x = NotifyBlockRemovedResponse{}
        mi := &amp;file_notifications_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NotifyBlockRemovedResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NotifyBlockRemovedResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NotifyBlockRemovedResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notifications_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NotifyBlockRemovedResponse.ProtoReflect.Descriptor instead.
func (*NotifyBlockRemovedResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notifications_proto_rawDescGZIP(), []int{5}
}</span>

var File_notifications_proto protoreflect.FileDescriptor

const file_notifications_proto_rawDesc = "" +
        "\n" +
        "\x13notifications.proto\x12\fnotification\"\xa3\x01\n" +
        "\x19NotifyBlockPresentRequest\x12\x12\n" +
        "\x04host\x18\x01 \x01(\tR\x04host\x12\x18\n" +
        "\ablockId\x18\x02 \x01(\tR\ablockId\x12\x12\n" +
        "\x04path\x18\x03 \x01(\tR\x04path\x12\x10\n" +
        "\x03crc\x18\x04 \x01(\rR\x03crc\x12\x1a\n" +
        "\bsequence\x18\x05 \x01(\x04R\bsequence\x12\x16\n" +
        "\x06length\x18\x06 \x01(\rR\x06length\"\x1c\n" +
        "\x1aNotifyBlockPresentResponse\"\xa1\x01\n" +
        "\x17NotifyBlockAddedRequest\x12\x12\n" +
        "\x04host\x18\x01 \x01(\tR\x04host\x12\x18\n" +
        "\ablockId\x18\x02 \x01(\tR\ablockId\x12\x12\n" +
        "\x04path\x18\x03 \x01(\tR\x04path\x12\x10\n" +
        "\x03crc\x18\x04 \x01(\rR\x03crc\x12\x1a\n" +
        "\bsequence\x18\x05 \x01(\x04R\bsequence\x12\x16\n" +
        "\x06length\x18\x06 \x01(\rR\x06length\"\x1a\n" +
        "\x18NotifyBlockAddedResponse\"]\n" +
        "\x19NotifyBlockRemovedRequest\x12\x12\n" +
        "\x04host\x18\x01 \x01(\tR\x04host\x12\x18\n" +
        "\ablockId\x18\x02 \x01(\tR\ablockId\x12\x12\n" +
        "\x04path\x18\x03 \x01(\tR\x04path\"\x1c\n" +
        "\x1aNotifyBlockRemovedResponse2\xc3\x02\n" +
        "\fNotification\x12g\n" +
        "\x12NotifyBlockPresent\x12'.notification.NotifyBlockPresentRequest\x1a(.notification.NotifyBlockPresentResponse\x12a\n" +
        "\x10NotifyBlockAdded\x12%.notification.NotifyBlockAddedRequest\x1a&amp;.notification.NotifyBlockAddedResponse\x12g\n" +
        "\x12NotifyBlockRemoved\x12'.notification.NotifyBlockRemovedRequest\x1a(.notification.NotifyBlockRemovedResponseB\n" +
        "Z\b./;protob\x06proto3"

var (
        file_notifications_proto_rawDescOnce sync.Once
        file_notifications_proto_rawDescData []byte
)

func file_notifications_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_notifications_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_notifications_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_notifications_proto_rawDesc), len(file_notifications_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_notifications_proto_rawDescData</span>
}

var file_notifications_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_notifications_proto_goTypes = []any{
        (*NotifyBlockPresentRequest)(nil),  // 0: notification.NotifyBlockPresentRequest
        (*NotifyBlockPresentResponse)(nil), // 1: notification.NotifyBlockPresentResponse
        (*NotifyBlockAddedRequest)(nil),    // 2: notification.NotifyBlockAddedRequest
        (*NotifyBlockAddedResponse)(nil),   // 3: notification.NotifyBlockAddedResponse
        (*NotifyBlockRemovedRequest)(nil),  // 4: notification.NotifyBlockRemovedRequest
        (*NotifyBlockRemovedResponse)(nil), // 5: notification.NotifyBlockRemovedResponse
}
var file_notifications_proto_depIdxs = []int32{
        0, // 0: notification.Notification.NotifyBlockPresent:input_type -&gt; notification.NotifyBlockPresentRequest
        2, // 1: notification.Notification.NotifyBlockAdded:input_type -&gt; notification.NotifyBlockAddedRequest
        4, // 2: notification.Notification.NotifyBlockRemoved:input_type -&gt; notification.NotifyBlockRemovedRequest
        1, // 3: notification.Notification.NotifyBlockPresent:output_type -&gt; notification.NotifyBlockPresentResponse
        3, // 4: notification.Notification.NotifyBlockAdded:output_type -&gt; notification.NotifyBlockAddedResponse
        5, // 5: notification.Notification.NotifyBlockRemoved:output_type -&gt; notification.NotifyBlockRemovedResponse
        3, // [3:6] is the sub-list for method output_type
        0, // [0:3] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_notifications_proto_init() }</span>
func file_notifications_proto_init() <span class="cov0" title="0">{
        if File_notifications_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_notifications_proto_rawDesc), len(file_notifications_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_notifications_proto_goTypes,
                DependencyIndexes: file_notifications_proto_depIdxs,
                MessageInfos:      file_notifications_proto_msgTypes,
        }.Build()
        File_notifications_proto = out.File
        file_notifications_proto_goTypes = nil
        file_notifications_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: notifications.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Notification_NotifyBlockPresent_FullMethodName = "/notification.Notification/NotifyBlockPresent"
        Notification_NotifyBlockAdded_FullMethodName   = "/notification.Notification/NotifyBlockAdded"
        Notification_NotifyBlockRemoved_FullMethodName = "/notification.Notification/NotifyBlockRemoved"
)

// NotificationClient is the client API for Notification service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationClient interface {
        NotifyBlockPresent(ctx context.Context, in *NotifyBlockPresentRequest, opts ...grpc.CallOption) (*NotifyBlockPresentResponse, error)
        NotifyBlockAdded(ctx context.Context, in *NotifyBlockAddedRequest, opts ...grpc.CallOption) (*NotifyBlockAddedResponse, error)
        NotifyBlockRemoved(ctx context.Context, in *NotifyBlockRemovedRequest, opts ...grpc.CallOption) (*NotifyBlockRemovedResponse, error)
}

type notificationClient struct {
        cc grpc.ClientConnInterface
}

func NewNotificationClient(cc grpc.ClientConnInterface) NotificationClient <span class="cov0" title="0">{
        return &amp;notificationClient{cc}
}</span>

func (c *notificationClient) NotifyBlockPresent(ctx context.Context, in *NotifyBlockPresentRequest, opts ...grpc.CallOption) (*NotifyBlockPresentResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(NotifyBlockPresentResponse)
        err := c.cc.Invoke(ctx, Notification_NotifyBlockPresent_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *notificationClient) NotifyBlockAdded(ctx context.Context, in *NotifyBlockAddedRequest, opts ...grpc.CallOption) (*NotifyBlockAddedResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(NotifyBlockAddedResponse)
        err := c.cc.Invoke(ctx, Notification_NotifyBlockAdded_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *notificationClient) NotifyBlockRemoved(ctx context.Context, in *NotifyBlockRemovedRequest, opts ...grpc.CallOption) (*NotifyBlockRemovedResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(NotifyBlockRemovedResponse)
        err := c.cc.Invoke(ctx, Notification_NotifyBlockRemoved_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// NotificationServer is the server API for Notification service.
// All implementations must embed UnimplementedNotificationServer
// for forward compatibility.
type NotificationServer interface {
        NotifyBlockPresent(context.Context, *NotifyBlockPresentRequest) (*NotifyBlockPresentResponse, error)
        NotifyBlockAdded(context.Context, *NotifyBlockAddedRequest) (*NotifyBlockAddedResponse, error)
        NotifyBlockRemoved(context.Context, *NotifyBlockRemovedRequest) (*NotifyBlockRemovedResponse, error)
        mustEmbedUnimplementedNotificationServer()
}

// UnimplementedNotificationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotificationServer struct{}

func (UnimplementedNotificationServer) NotifyBlockPresent(context.Context, *NotifyBlockPresentRequest) (*NotifyBlockPresentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method NotifyBlockPresent not implemented")
}</span>
func (UnimplementedNotificationServer) NotifyBlockAdded(context.Context, *NotifyBlockAddedRequest) (*NotifyBlockAddedResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method NotifyBlockAdded not implemented")
}</span>
func (UnimplementedNotificationServer) NotifyBlockRemoved(context.Context, *NotifyBlockRemovedRequest) (*NotifyBlockRemovedResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method NotifyBlockRemoved not implemented")
}</span>
func (UnimplementedNotificationServer) mustEmbedUnimplementedNotificationServer() {<span class="cov0" title="0">}</span>
func (UnimplementedNotificationServer) testEmbeddedByValue()                      {<span class="cov0" title="0">}</span>

// UnsafeNotificationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServer will
// result in compilation errors.
type UnsafeNotificationServer interface {
        mustEmbedUnimplementedNotificationServer()
}

func RegisterNotificationServer(s grpc.ServiceRegistrar, srv NotificationServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedNotificationServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Notification_ServiceDesc, srv)</span>
}

func _Notification_NotifyBlockPresent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(NotifyBlockPresentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NotificationServer).NotifyBlockPresent(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Notification_NotifyBlockPresent_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NotificationServer).NotifyBlockPresent(ctx, req.(*NotifyBlockPresentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Notification_NotifyBlockAdded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(NotifyBlockAddedRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NotificationServer).NotifyBlockAdded(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Notification_NotifyBlockAdded_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NotificationServer).NotifyBlockAdded(ctx, req.(*NotifyBlockAddedRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Notification_NotifyBlockRemoved_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(NotifyBlockRemovedRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NotificationServer).NotifyBlockRemoved(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Notification_NotifyBlockRemoved_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NotificationServer).NotifyBlockRemoved(ctx, req.(*NotifyBlockRemovedRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Notification_ServiceDesc is the grpc.ServiceDesc for Notification service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Notification_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "notification.Notification",
        HandlerType: (*NotificationServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "NotifyBlockPresent",
                        Handler:    _Notification_NotifyBlockPresent_Handler,
                },
                {
                        MethodName: "NotifyBlockAdded",
                        Handler:    _Notification_NotifyBlockAdded_Handler,
                },
                {
                        MethodName: "NotifyBlockRemoved",
                        Handler:    _Notification_NotifyBlockRemoved_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "notifications.proto",
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
